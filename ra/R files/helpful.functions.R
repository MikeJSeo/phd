#helpful functions

####### convenient function to combine mcmc chains used in first stage analysis
add.mcmc <- function(x,y){
  
  n.chains <- length(x)
  n.var <- nvar(x)
  newobjects <- vector("list", length = n.chains)
  
  for(i in 1:n.chains){
    newobjects[[i]] <- matrix(NA, nrow = 0, ncol = n.var, dimnames = list(NULL, dimnames(x[[1]])[[2]]))
    newobjects[[i]] <- rbind(x[[i]], y[[i]])
    newobjects[[i]] <- mcmc(newobjects[[i]])
  }
  mcmc.list(newobjects)
}


######## first stage model
firstStage <- function(study_data, jags_file, mm = 20, index = c("a", "b", "c", "d", "sigma")){
  
  y <- study_data$DAS28
  X <- as.matrix(study_data[,c(-1,-2,-3)])
  X <- apply(X, 2, scale)
  XX <- mice(cbind(y,X), m = mm)
  
  if(length(unique(study_data$treat)) == 2){
    study_data$treat[study_data$treat == "3"] <- "2"
  }
  
  jags_data <- list(
    N = length(y),
    treat = study_data$treat,
    Ncovariate = dim(X)[2],
    Ntreat = length(unique(study_data$treat)),
    y = y,
    X = complete(XX, 1)[,-1]
  )
  mod <- jags.model(file = jags_file, data = jags_data, n.chains = 3, n.adapt = 1000)
  samples <- coda.samples(mod, variable.names = index, n.iter = 10000)
  
  if(mm != 1){
  # add more samples
  for(i in 2:mm){
    
    jags_data <- list(
      N = length(y),
      treat = study_data$treat,
      Ncovariate = dim(X)[2],
      Ntreat = length(unique(study_data$treat)),
      y = y,
      X = complete(XX, i)[,-1]
    )
    mod <- jags.model(file = jags_file, data = jags_data, n.chains = 3, n.adapt = 1000)
    stats::update(mod, 1000)
    sample_more <- coda.samples(mod, variable.names = index, n.iter = 10000)
    samples <- add.mcmc(samples, sample_more)
  }
  }  
  return(samples)
}


# summarize each first stage analysis

summarize_each_study <- function(samples){
  
  samples_result <- as.matrix(samples)
  samples_result <- samples_result[, colSums(samples_result != 0) > 0] #delete 0 value variables
  
  Vars <- grep("^a", colnames(samples_result))
  Vars <- c(Vars, grep("^b", colnames(samples_result)))
  Vars <- c(Vars, grep("^c", colnames(samples_result)))
  Vars <- c(Vars, grep("^d", colnames(samples_result)))
  
  samples_result <- samples_result[,Vars]
  y <- apply(samples_result, 2, mean)
  Sigma <- cov(samples_result)
  Omega <- solve(Sigma)
  
  return(list(y = y, Omega = Omega))
}

#second stage analysis using results from first stage analysis
secondStage <- function(y, Omega, W = NULL, jags_file = NULL, n.iter = 200000){
  
  data_jags <- c(y, Omega)
  if(!is.null(W)){
    data_jags$W <- W  
  }
  
  mod <- jags.model(jags_file, data_jags, n.chains = 3, n.adapt = 1000)
  stats::update(mod, 20000)
  
  var.names <- c("alpha", "beta", "gamma", "delta")
  samples <- coda.samples(mod, variable.names = var.names, n.iter = n.iter, n.chains = 3)
  
  return(samples) 
}
  
# function to find predictions for a specified dataset using the second stage result
# Note that this function is specific to the RA dataset and uses 9 specified covariates; i.e. will give an error if applied to other datasets
# prediction is divided by three groups according to treatments assigned
findPrediction <- function(data, result) {
  
  options(na.action='na.pass')
  abd <- model.matrix(~ female + age + duration + baseBMI + baseRF + n_prev_dmards_antiTNF + baseHAQ + baseESR + baseDAS + treat, data)
  abd_scaled <- abd
  abd_scaled[,c(-1,-11,-12)] <- apply(abd[,c(-1,-11,-12)], 2, scale) #scale except intercept and treatment indexes
  
  g2 <- model.matrix(~ (female + age + duration + baseBMI + baseRF + n_prev_dmards_antiTNF + baseHAQ + baseESR + baseDAS)*I(data$treat == 2),as.data.frame(abd_scaled))[,-c(1:(9+2))]
  g3 <- model.matrix(~ (female + age + duration + baseBMI + baseRF + n_prev_dmards_antiTNF + baseHAQ + baseESR + baseDAS)*I(data$treat == 3),as.data.frame(abd_scaled))[,-c(1:(9+2))]
  
  XX <- as.matrix(cbind(abd_scaled, g2, g3))
  X <- XX[complete.cases(XX),] # use only the complete cases for predictions
  
  coefs <- summary(result)[[1]][,"Mean"]
  coefs <- coefs[coefs != 0] #remove coefficients with zero values
  
  y <- data$DAS28[complete.cases(XX)]
  treat <- data$treat[complete.cases(XX)]
  pred <- X %*% coefs
  
  index1 <- X[,"treat2"] == 0 & X[,"treat3"] == 0
  index2 <- X[,"treat2"] == 1
  index3 <- X[,"treat3"] == 1
  
  y1 <- y[index1]
  y2 <- y[index2]
  y3 <- y[index3]
  
  pred1 <- pred[index1]
  pred2 <- pred[index2]
  pred3 <- pred[index3]
  
  coefs1 <- coefs * c(rep(1,10), rep(0, 2), rep(0, 9), rep(0, 9))
  pred_full_1 <- X %*% coefs1
  
  coefs2 <- coefs * c(rep(1,10), 1, 0, rep(1, 9), rep(0, 9))
  pred_full_2 <- X %*% coefs2
  
  coefs3 <- coefs * c(rep(1,10), 0, 1, rep(0, 9), rep(1, 9))
  pred_full_3 <- X %*% coefs3
    
  #calibration slope
  pred_full_11 <- pred_full_1
  
  pred_full_12 <- pred_full_2 - pred_full_1
  pred_full_12 <- pred_full_12 * (treat == "2")
  
  pred_full_13 <- pred_full_3 - pred_full_1
  pred_full_13 <- pred_full_13 * (treat == "3")
  
  pred_full_1 <- pred_full_1 * (treat == "1")
  pred_full_2 <- pred_full_2 * (treat == "2")
  pred_full_3 <- pred_full_3 * (treat == "3")
  
  return(list(y = y, y1 = y1, y2 = y2, y3 = y3, treat = treat, X = X, pred = pred,
              pred1 = pred1, pred2 = pred2, pred3 = pred3, coefs = coefs,
              pred_full_11 = pred_full_11, pred_full_12 = pred_full_12, pred_full_13 = pred_full_13, 
              pred_full_1 = pred_full_1, pred_full_2 = pred_full_2, pred_full_3 = pred_full_3))
}

findMSE <- function(y, pred){
  err_mse <- (pred-y)^2
  err_mse <- err_mse[!is.na(err_mse)]
  err_mse
}

findBias <- function(y, pred){
  err_bias <- pred-y
  err_bias <- err_bias[!is.na(err_bias)]
  err_bias
}


# find performance metric based on predictions
findPerformance <- function(prediction){
  
  result <-
  with(prediction,{
    mse <- findMSE(y, pred)
    bias <- findBias(y, pred)
    
    mse1 <-  findMSE(y1, pred1)
    bias1 <- findBias(y1, pred1)
    
    mse2 <- findMSE(y2, pred2)
    bias2 <- findBias(y2, pred2)
    
    mse3 <- findMSE(y3, pred3)
    bias3 <- findBias(y3, pred3)
    
    list(mse = mse, bias = bias, mse1 = mse1, bias1 = bias1, mse2 = mse2, bias2 = bias2, 
         mse3 = mse3, bias3 = bias3)
  })
  
  result
}

# Calibration plot
findPerformance2 <- function(prediction){
  
  result <- 
  with(prediction,{
    slope1 <- lm(y ~ pred_full_1 + pred_full_2 + pred_full_3, na.action=na.exclude)
    slope2 <- lm(y ~ pred_full_11 + pred_full_12 + pred_full_13, na.action=na.exclude)  
    list(slope1 = slope1, slope2 = slope2)
  })
  result
}

calibrationPlot <- function(prediction, treatment = 1){
  
  with(prediction,{
    
    if(treatment == 1){
      data <- data.frame(y = y1, pred = pred_full_1[treat == "1"])
      data <- data[complete.cases(data),]
    }
    ggplot(data = data, aes(x = pred, y = y)) + geom_point()
  })
}
