knitr::opts_chunk$set(tidy = TRUE, tidy.opts=list(blank=FALSE, width.cutoff=60), warning = FALSE, message=FALSE, echo = FALSE)
library(MASS) # Used for data simulation
library(lme4) #for fitting glmm
library(glmnet) #for lasso
library(glmmLasso) #for glmmLasso
library(dclone) # for parallel processing of JAGS code
library(knitr) # for tables
setwd("C:/Users/mike/Desktop")
#load/save everything else from/to github
#setwd("~/GitHub/phd/varselect")
setwd("C:/Users/mike/Desktop/Github/phd/varselect")
source("run.simulation.functions.R")
source("helpful.functions.R")
# setup for parallel computing
n.cores <- 2
cl <- makePSOCKcluster(n.cores)
tmp <- clusterEvalQ(cl, library(dclone))
# number of simulation to run
niter <- 1000
niter <- 2
### parameters to change ###
col_labels_glmm <- c(paste0("treat:", "X", 1:5), "treat")
col_labels <- c(paste0("X", 1:5, ":treat"), "treat")
col_labels_glmmLasso <- c(paste0("X", 1:5, "_treat"), "treat")
correct_em <- c(0, 0, 1, 0, 0)
correct_em_values <- c(0, 0, 0.1, 0, 0)
Nstudies <- 5
Ncovariate <- 5
continuous.cov <- c(1, 3, 4)
pf <- c(1,2,3)
em <- 3
b1 <- c(0.1, 0.5, 0.1)
b2 <- 0.1
glmm_null_formula <- as.formula("y ~ studyid + treat + (-1 + treat|studyid)")
glmm_full_formula <- as.formula("y ~ studyid + treat + (X1 + X2 + X3 + X4 + X5)*treat + (-1 + treat|studyid)")
step_full_formula <-  as.formula("y ~ (X1 + X2 + X3 + X4 + X5)*treat")
glmmLasso_formula <- as.formula("y ~ as.factor(studyid) + X1 + X2 + X3 + X4 + X5 + X1_treat + X2_treat + X3_treat + X4_treat + X5_treat + treat")
model.type = "gaussian"
bayesLASSO_store_mse <- matrix(NA, nrow = niter, ncol = 3)
bayesLASSO_store_sd <- matrix(NA, nrow = niter, ncol = 3)
for(i in seq(niter)){
set.seed(i)
data <-generate.simulation(Nstudies = Nstudies, Ncovariate = Ncovariate, continuous.cov = continuous.cov, pf = pf, em = em, b1 = b1, b2 = b2)
data_jags <- with(data,{
list(Nstudies = length(unique(studyid)),
X = data[,paste0("X",1:Ncovariate)],
Np = length(X1),
Ncovariate = (dim(data)[2] - 3)/2,
studyid = studyid,
treat = treat + 1,
y = y)
})
samples <- jags.parfit(cl = cl, data = data_jags, params = c("g", "d"), model = "IPD-MA-bayesLASSO.txt", n.chains = 2, n.adapt = 100, n.update = 200, n.iter = 2000)
a <- summary(samples)
g_mean <-  a$statistics[grep("g\\[", rownames(a$statistics)), "Mean"]
treat_mean <- a$statistics[grep("d\\[", rownames(a$statistics)), "Mean"]
treat_mean <- treat_mean["d[2]"]
names(treat_mean) <- "treat"
mean_values <- c(g_mean, treat_mean)
bayesLASSO_store_mse[i,] <- find_performance(mean_values, correct_em_values, correct_em)
g_sd <-  a$statistics[grep("g\\[", rownames(a$statistics)), "SD"]
treat_sd <- a$statistics[grep("d\\[", rownames(a$statistics)), "SD"]
treat_sd <- treat_sd["d[2]"]
names(treat_sd) <- "treat"
sd_values <- c(g_sd, treat_sd)
bayesLASSO_store_sd[i,] <- find_performance2(sd_values, correct_em)
}
SSVS_store_mse <- matrix(NA, nrow = niter, ncol = 3)
SSVS_store_sd <- matrix(NA, nrow = niter, ncol = 3)
for(i in seq(niter)){
set.seed(i)
data <-generate.simulation(Nstudies = Nstudies, Ncovariate = Ncovariate, continuous.cov = continuous.cov, pf = pf, em = em, b1 = b1, b2 = b2)
data_jags <- with(data,{
list(Nstudies = length(unique(studyid)),
X = data[,paste0("X",1:Ncovariate)],
Np = length(X1),
Ncovariate = (dim(data)[2] - 3)/2,
studyid = studyid,
treat = treat + 1,
y = y)
})
samples <- jags.parfit(cl = cl, data = data_jags, params = c("g", "d"), model = "IPD-MA-SSVS.txt", n.chains = 2, n.adapt = 100, n.update = 200, n.iter = 2000)
a <- summary(samples)
g_mean <-  a$statistics[grep("g\\[", rownames(a$statistics)), "Mean"]
treat_mean <- a$statistics[grep("d\\[", rownames(a$statistics)), "Mean"]
treat_mean <- treat_mean["d[2]"]
names(treat_mean) <- "treat"
mean_values <- c(g_mean, treat_mean)
SSVS_store_mse[i,] <- find_performance(mean_values, correct_em_values, correct_em)
g_sd <-  a$statistics[grep("g\\[", rownames(a$statistics)), "SD"]
treat_sd <- a$statistics[grep("d\\[", rownames(a$statistics)), "SD"]
treat_sd <- treat_sd["d[2]"]
names(treat_sd) <- "treat"
sd_values <- c(g_sd, treat_sd)
SSVS_store_sd[i,] <- find_performance2(sd_values, correct_em)
}
bayesLASSO_store_mse_mean <- apply(bayesLASSO_store_mse, 2, mean)
bayesLASSO_store_sd_mean <- apply(bayesLASSO_store_sd, 2, mean, na.rm = TRUE)
SSVS_store_mse_mean <- apply(SSVS_store_mse, 2, mean)
SSVS_store_sd_mean <- apply(glmm_full_store_sd, 2, mean, na.rm = TRUE)
bayesLASSO_store_mse_mean <- apply(bayesLASSO_store_mse, 2, mean)
bayesLASSO_store_sd_mean <- apply(bayesLASSO_store_sd, 2, mean, na.rm = TRUE)
SSVS_store_mse_mean <- apply(SSVS_store_mse, 2, mean)
SSVS_store_sd_mean <- apply(SSVS_store_sd, 2, mean, na.rm = TRUE)
result_matrix_mse <- matrix(NA, nrow = 2, ncol = 3)
colnames(result_matrix_mse) <- c("false em mse", "true em mse","treatment mse")
rownames(result_matrix_mse) <-  c("bayesLASSO", "SSVS")
result_matrix_mse[1,] <- bayesLASSO_store_mse_mean
result_matrix_mse[2,] <- SSVS_store_mse_mean
result_matrix_sd <- matrix(NA, nrow = 2, ncol = 3)
colnames(result_matrix_sd) <- c("continuous EM se", "binary EM se","treatment se")
rownames(result_matrix_sd) <-  c("bayesLASSO", "SSVS")
result_matrix_sd[1,] <- bayesLASSO_store_sd_mean
result_matrix_sd[2,] <- SSVS_store_sd_mean
cbind(result_matrix_mse, result_matrix_sd)
# install.packages("devtools")
devtools::install_github("MikeJSeo/network-meta")
# install.packages("devtools")
devtools::install_github("MikeJSeo/bnma")
# install.packages("devtools")
devtools::install_github("MikeJSeo/bnma")
install.packages("digest")
install.packages("digest")
# install.packages("devtools")
devtools::install_github("MikeJSeo/bnma")
knitr::opts_chunk$set(tidy = TRUE, tidy.opts=list(blank=FALSE, width.cutoff=60), warning = FALSE, message=FALSE, echo = FALSE)
# Setting directory
#etwd("C:/Users/ms19g661/Desktop")
setwd("C:/Users/mike/Desktop")
#load/save everything else from/to github
#setwd("~/GitHub/phd/varselect")
setwd("C:/Users/mike/Desktop/Github/phd/varselect")
source("run.simulation.functions.R")
source("helpful.functions.R")
# setup for parallel computing
n.cores <- 2
cl <- makePSOCKcluster(n.cores)
library(MASS) # Used for data simulation
library(lme4) #for fitting glmm
library(glmnet) #for lasso
library(glmmLasso) #for glmmLasso
library(dclone) # for parallel processing of JAGS code
library(knitr) # for tables
library(nlme) # for initial values for glmmLasso
# number of simulation to run
niter <- 10
### parameters to change ###
col_labels_glmm <- c(paste0("treat:", "X", 1:5), "treat")
col_labels <- c(paste0("X", 1:5, ":treat"), "treat")
col_labels_glmmLasso <- c(paste0("X", 1:5, "_treat"), "treat")
correct_em <- c(0, 0, 1, 0, 0)
correct_em_values <- c(0, 0, 0.1, 0, 0)
Nstudies <- 5
Ncovariate <- 5
continuous.cov <- c(1, 3, 4)
pf <- c(1,2,3)
em <- 3
b1 <- c(0.1, 0.5, 0.1)
b2 <- 0.1
glmm_null_formula <- as.formula("y ~ studyid + treat + (-1 + treat|studyid)")
glmm_full_formula <- as.formula("y ~ studyid + treat + (X1 + X2 + X3 + X4 + X5)*treat + (-1 + treat|studyid)")
step_full_formula <-  as.formula("y ~ (X1 + X2 + X3 + X4 + X5)*treat")
glmmLasso_formula <- as.formula("y ~ as.factor(studyid) + X1 + X2 + X3 + X4 + X5 + X1_treat + X2_treat + X3_treat + X4_treat + X5_treat + treat")
pql_formula <- as.formula("y ~ studyid + (X1 + X2 + X3 + X4 + X5)*treat")
model.type = "gaussian"
simulation1.a <- run.simulation()
set.seed(i)
data <-generate.simulation(Nstudies = Nstudies, Ncovariate = Ncovariate, continuous.cov = continuous.cov, pf = pf, em = em, b1 = b1, b2 = b2)
#This part is used for setting initial values
#if(model.type == "gaussian"){
#  PQL <-glmmPQL(pql_formula, random = ~ -1 + treat|studyid, family=gaussian, data=data)
#}
#q_start <- as.numeric(VarCorr(PQL)[1,1])
#start <- as.numeric(c(PQL$coef$fixed[-which(names(PQL$coef$fixed) == "treat")], PQL$coef$fixed[which(names(PQL$coef$fixed) == "treat")], t(PQL$coef$random$studyid)))
q_start <- NULL
start <- NULL
colnames(data) <- gsub(":", "_", colnames(data)) #glmmLasso doesn't allow colon sign
form.fixed <- glmmLasso_formula
form.rnd <- list(studyid =~ -1 + treat)
if(model.type == "gaussian") {
cv.fit <- cv.glmmLasso(data, form.fixed = form.fixed, form.rnd = form.rnd, lambda = seq(100, 0, by = -5), family = gaussian(link="identity"), q_start = q_start, start = start)
}
aa <- summary(cv.fit[[1]])$coefficients
aa <- rownames(aa[aa[,"Estimate"] != 0,])
mean_values <- sapply(col_labels_glmmLasso, function(x) ifelse(x %in% aa, summary(cv.fit[[1]])$coefficients[x,"Estimate"], 0))
sd_values <- bootstrap_function_glmmLasso(data, 100, cv.fit[[2]], model.type, form.fixed, form.rnd, q_start, start)
sd_values
find_performance2(sd_values, correct_em, continuous.cov)
data <-generate.simulation(Nstudies = Nstudies, Ncovariate = Ncovariate, continuous.cov = continuous.cov, pf = pf, em = em, b1 = b1, b2 = b2)
data_jags <- with(data,{
list(Nstudies = length(unique(studyid)),
X = data[,paste0("X",1:Ncovariate)],
Np = length(X1),
Ncovariate = (dim(data)[2] - 3)/2,
studyid = studyid,
treat = treat + 1,
y = y)
})
data <-generate.simulation(Nstudies = Nstudies, Ncovariate = Ncovariate, continuous.cov = continuous.cov, pf = pf, em = em, b1 = b1, b2 = b2)
#This part is used for setting initial values
#if(model.type == "gaussian"){
#  PQL <-glmmPQL(pql_formula, random = ~ -1 + treat|studyid, family=gaussian, data=data)
#}
#q_start <- as.numeric(VarCorr(PQL)[1,1])
#start <- as.numeric(c(PQL$coef$fixed[-which(names(PQL$coef$fixed) == "treat")], PQL$coef$fixed[which(names(PQL$coef$fixed) == "treat")], t(PQL$coef$random$studyid)))
q_start <- NULL
start <- NULL
colnames(data) <- gsub(":", "_", colnames(data)) #glmmLasso doesn't allow colon sign
form.fixed <- glmmLasso_formula
form.rnd <- list(studyid =~ -1 + treat)
if(model.type == "gaussian") {
cv.fit <- cv.glmmLasso(data, form.fixed = form.fixed, form.rnd = form.rnd, lambda = seq(20, 0, by = -1), family = gaussian(link="identity"), q_start = q_start, start = start)
}
cv.fit
colnames(data) <- gsub(":", "_", colnames(data)) #glmmLasso doesn't allow colon sign
form.fixed <- glmmLasso_formula
form.rnd <- list(studyid =~ -1 + treat)
if(model.type == "gaussian") {
cv.fit <- cv.glmmLasso(data, form.fixed = form.fixed, form.rnd = form.rnd, lambda = seq(100, 0, by = -5), family = gaussian(link="identity"), q_start = q_start, start = start)
}
cv.fit
colnames(data) <- gsub(":", "_", colnames(data)) #glmmLasso doesn't allow colon sign
form.fixed <- glmmLasso_formula
form.rnd <- list(studyid =~ -1 + treat)
if(model.type == "gaussian") {
cv.fit <- cv.glmmLasso(data, form.fixed = form.fixed, form.rnd = form.rnd, lambda = seq(100, 0, by = -5), family = gaussian(link="identity"), q_start = q_start, start = start)
}
data <-generate.simulation(Nstudies = Nstudies, Ncovariate = Ncovariate, continuous.cov = continuous.cov, pf = pf, em = em, b1 = b1, b2 = b2)
#This part is used for setting initial values
#if(model.type == "gaussian"){
#  PQL <-glmmPQL(pql_formula, random = ~ -1 + treat|studyid, family=gaussian, data=data)
#}
#q_start <- as.numeric(VarCorr(PQL)[1,1])
#start <- as.numeric(c(PQL$coef$fixed[-which(names(PQL$coef$fixed) == "treat")], PQL$coef$fixed[which(names(PQL$coef$fixed) == "treat")], t(PQL$coef$random$studyid)))
q_start <- NULL
start <- NULL
colnames(data) <- gsub(":", "_", colnames(data)) #glmmLasso doesn't allow colon sign
form.fixed <- glmmLasso_formula
form.rnd <- list(studyid =~ -1 + treat)
if(model.type == "gaussian") {
cv.fit <- cv.glmmLasso(data, form.fixed = form.fixed, form.rnd = form.rnd, lambda = seq(100, 0, by = -5), family = gaussian(link="identity"), q_start = q_start, start = start)
}
cv.fit
i = 1
N <- dim(data)[1]
ind <- sample(N, N)
kk <- 5 # 5 fold cross validation
nk <- floor(N/kk)
cv.measure <- matrix(Inf, ncol = kk, nrow = length(lambda))
for(j in 1:length(lambda)){
print(paste("Iteration ", j,sep=""))
}
lambda <- seq(100, 0, by = -5)
lambda
if (i < kk){
indi <- ind[(i-1)*nk+(1:nk)]
} else{
indi <- ind[((i-1)*nk+1):N]
}
data_train <- data[-indi,]
data_test <- data[indi,]
data_jags <- with(data_train,{
list(Nstudies = length(unique(studyid)),
X = data_train[,paste0("X",1:Ncovariate)],
Np = length(X1),
Ncovariate = (dim(data_train)[2] - 3)/2,
studyid = studyid,
treat = treat + 1,
y = y)
})
samples <- jags.parfit(cl = cl, data = data_jags, params = c("alpha", "beta", "delta", "g"), model = "IPD-MA-bayesLASSO.txt", n.chains = 2, n.adapt = 100, n.update = 200, n.iter = 2000)
# setup for parallel computing
n.cores <- 2
cl <- makePSOCKcluster(n.cores)
tmp <- clusterEvalQ(cl, library(dclone))
# number of simulation to run
niter <- 1000
if (i < kk){
indi <- ind[(i-1)*nk+(1:nk)]
} else{
indi <- ind[((i-1)*nk+1):N]
}
data_train <- data[-indi,]
data_test <- data[indi,]
data_jags <- with(data_train,{
list(Nstudies = length(unique(studyid)),
X = data_train[,paste0("X",1:Ncovariate)],
Np = length(X1),
Ncovariate = (dim(data_train)[2] - 3)/2,
studyid = studyid,
treat = treat + 1,
y = y)
})
samples <- jags.parfit(cl = cl, data = data_jags, params = c("alpha", "beta", "delta", "g"), model = "IPD-MA-bayesLASSO.txt", n.chains = 2, n.adapt = 100, n.update = 200, n.iter = 2000)
#etwd("C:/Users/ms19g661/Desktop")
setwd("C:/Users/mike/Desktop")
#load/save everything else from/to github
#setwd("~/GitHub/phd/varselect")
setwd("C:/Users/mike/Desktop/Github/phd/varselect")
source("run.simulation.functions.R")
source("helpful.functions.R")
library(MASS) # Used for data simulation
library(lme4) #for fitting glmm
library(glmnet) #for lasso
library(glmmLasso) #for glmmLasso
library(dclone) # for parallel processing of JAGS code
library(knitr) # for tables
library(nlme) # for initial values for glmmLasso
if (i < kk){
indi <- ind[(i-1)*nk+(1:nk)]
} else{
indi <- ind[((i-1)*nk+1):N]
}
data_train <- data[-indi,]
data_test <- data[indi,]
data_jags <- with(data_train,{
list(Nstudies = length(unique(studyid)),
X = data_train[,paste0("X",1:Ncovariate)],
Np = length(X1),
Ncovariate = (dim(data_train)[2] - 3)/2,
studyid = studyid,
treat = treat + 1,
y = y)
})
samples <- jags.parfit(cl = cl, data = data_jags, params = c("alpha", "beta", "delta", "g"), model = "IPD-MA-bayesLASSO.txt", n.chains = 2, n.adapt = 100, n.update = 200, n.iter = 2000)
getwd()
#etwd("C:/Users/ms19g661/Desktop")
setwd("C:/Users/mike/Desktop")
#load/save everything else from/to github
#setwd("~/GitHub/phd/varselect")
setwd("C:/Users/mike/Desktop/Github/phd/varselect")
getwd()
