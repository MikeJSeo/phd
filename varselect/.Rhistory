}
}
}
if(!is.null(covariate)){
for(i in seq(dim(covariate)[2])){
pars.save = c(pars.save, paste("beta",i,sep = ""))
}
}
pars.save <- unique(pars.save)
if(is.null(inits)){
if(!any(is.na(network$data))){
inits <- network.inits(network, n.chains)
}
}
samples <- jags.fit(network, data, pars.save, inits, n.chains, max.run, setsize, n.run, conv.limit)
result <- list(network = network, data.rjags = data, inits = inits, pars.save = pars.save)
result <- c(result, samples)
result$deviance <- calculate.deviance(result)
result$rank.tx <- rank.tx(result)
class(result) <- "network.result"
return(result)
})
}
jags.fit <- function(network, data, pars.save, inits, n.chains, max.run, setsize, n.run, conv.limit) {
mod = rjags::jags.model(textConnection(network$code), data = data, inits = inits, n.chains = n.chains, n.adapt = 0)
adapted <- FALSE
count <- 0
while(!adapted){
adapted <- rjags::adapt(mod, setsize, end.adaptation = FALSE)
count <- count + 1
if(count == 100){
stop("algorithm has not adapted")
}
}
if(class(network) == "network.data"){
conv.save <- if(network$response == "multinomial"){
c("d", "Eta", "sigma_transformed")
} else if(network$response == "binomial" || network$response == "normal"){
c("d", "Eta", "logvar")
}
if(network$type == "fixed"){
conv.save <- conv.save[!conv.save %in% c("logvar", "sigma_transformed")]
}
} else if(class(network) == "contrast.network.data" || class(network) == "ume.network.data" || class(network) == "nodesplit.network.data"){
conv.save <- pars.save
}
samples <- rjags::coda.samples(model = mod, variable.names = pars.save, n.iter = setsize)
varnames <- dimnames(samples[[1]])[[2]]
varnames.split <- sapply(strsplit(varnames, "\\["), '[[', 1)
conv.save.variables <- varnames.split %in% conv.save
max.gelman <- find.max.gelman(samples, conv.save.variables)
print(max.gelman)
check <- max.gelman > conv.limit
if(check) {
count <- 1
while (check & count < max.run/setsize) {
samples2 <- rjags::coda.samples(mod, variable.names = pars.save, n.iter = setsize)
samples <- add.mcmc(samples, samples2)
count <- count + 1
max.gelman <- find.max.gelman(samples, conv.save.variables)
check <- max.gelman > conv.limit
print(max.gelman)
}
}
start <- mcpar(samples[[1]])[1]
end <- mcpar(samples[[1]])[2]
mid <- (end + start-1)/2
burnin <- ceiling(end - mid)
samples <- window(samples, mid+1, end, 1) #keep the last half of the converged sequence
samples <- new.mcmc(samples)
n.thin <- 1
if(check == TRUE){
print("code didn't converge according to gelman-rubin diagnostics")
} else if(n.run < burnin){
n.thin <- ceiling(burnin/n.run)
extra.run <- n.run * n.thin - burnin
if(extra.run != 0){
samples2 <- rjags::coda.samples(mod, variable.names = pars.save, n.iter = extra.run)
samples <- add.mcmc(samples, samples2)
}
samples <- window(samples, 1, dim(samples[[1]])[1], n.thin)
} else if(n.run > burnin){
extra.run <- n.run - burnin
samples2 <- rjags::coda.samples(mod, variable.names = pars.save, n.iter = extra.run)
samples <- add.mcmc(samples, samples2)
}
max.gelman <- find.max.gelman(samples, conv.save.variables)
print(max.gelman)
out <-list(burnin = burnin, n.thin = n.thin, samples = samples, max.gelman = max.gelman, kappa = kappa)
return(out)
}
extra.pars.save.check <- function(extra.pars.save, pars.save){
if(!is.atomic(extra.pars.save) || !is.vector(extra.pars.save)) stop("extra pars should be a vector of strings")
for(i in 1:length(extra.pars.save)){
if(!is.character(extra.pars.save[i])) stop("extra pars should be a vector of strings")
if(extra.pars.save[i] %in% pars.save) stop(paste0(extra.pars.save[i], " is already one of default parameters to save") )
}
}
new.mcmc <- function(x){
n.chains <- length(x)
n.var <- nvar(x)
newobjects <- vector("list", length = n.chains)
for(i in 1:n.chains){
newobjects[[i]] <- matrix(NA, nrow = 0, ncol = n.var, dimnames = list(NULL, dimnames(x[[1]])[[2]]))
newobjects[[i]] <- x[[i]]
newobjects[[i]] <- mcmc(newobjects[[i]])
}
mcmc.list(newobjects)
}
add.mcmc <- function(x, y){
n.chains <- length(x)
n.var <- nvar(x)
newobjects <- vector("list", length = n.chains)
for(i in 1:n.chains){
newobjects[[i]] <- matrix(NA, nrow = 0, ncol = n.var, dimnames = list(NULL, dimnames(x[[1]])[[2]]))
newobjects[[i]] <- rbind(x[[i]], y[[i]])
newobjects[[i]] <- mcmc(newobjects[[i]])
}
mcmc.list(newobjects)
}
find.max.gelman <- function(samples, index){
samples2 <- lapply(samples, function(x){ x[,index]})
samples2 <- lapply(samples2, function(x) { x[,colSums(abs(x)) != 0] })
max(gelman.diag(samples2, multivariate = FALSE)$psrf[,1]) #look at point estimate instead of 95% C.I.
}
find.max.gelman.variable <- function(samples, index){
samples2 <- lapply(samples, function(x){ x[,index]})
samples2 <- lapply(samples2, function(x) { x[,colSums(abs(x)) != 0] })
names(which.max(gelman.diag(samples2, multivariate = FALSE)$psrf[,1])) # find the biggest
}
nodesplit.network.run <- function(network, inits = NULL, n.chains = 3, max.run = 100000, setsize = 10000, n.run = 50000,
conv.limit = 1.05){
if (!inherits(network, "nodesplit.network.data")) {
stop('Given network is not nodesplit.network.data. Run nodesplit.network.data function first')
}
if(max.run < setsize){
stop("setsize should be smaller than max.run")
}
with(network, {
data <- list(r = r, t = t, na = na)
if(response == "binomial" || response == "multinomial"){
data$n <- n
} else if(response == "normal"){
data$se <- se
}
data <- append(data, list(pair = pair, split = split, m =  m, bi = bi, si = si))
pars.save <- c("diff", "prob", "oneminusprob")
if(is.null(inits)){
inits <- list()
for(i in 1:n.chains){
inits[[i]] <- list(direct=0,  d=  c(NA, rep(0, ntreat - 1)), sd=1, mu=rep(0,nstudy))
}
}
samples <- jags.fit(network, data, pars.save, inits = NULL, n.chains, max.run, setsize, n.run, conv.limit)
result <- list(network = network, data.rjags = data, inits = inits, pars.save = pars.save)
result <- c(result, samples)
class(result) <- "nodesplit.network.result"
return(result)
})
}
network <- with(thrombolytic, nodesplit.network.data(Outcomes, Study, Treat, N, response = "binomial", pair = c(3,9)))
result <- nodesplit.network.run(network)
summary(result)
library(coda)
help(gelmna.diag)
gelman.diag
network <- with(thrombolytic, nodesplit.network.data(Outcomes, Study, Treat, N, response = "binomial", pair = c(3,9)))
result <- nodesplit.network.run(network)
summary(result)
with(network, {
data <- list(r = r, t = t, na = na)
if(response == "binomial" || response == "multinomial"){
data$n <- n
} else if(response == "normal"){
data$se <- se
}
data <- append(data, list(pair = pair, split = split, m =  m, bi = bi, si = si))
pars.save <- c("diff", "prob", "oneminusprob")
if(is.null(inits)){
inits <- list()
for(i in 1:n.chains){
inits[[i]] <- list(direct=0,  d=  c(NA, rep(0, ntreat - 1)), sd=1, mu=rep(0,nstudy))
}
}
})
data
data <- list(r = network$r, t = network$t, na = network$na)
network$response
data$n <- network$n
network$n
data <- append(data, list(pair = network$pair, split = network$split, m =  network$m, bi = network$bi, si = network$si))
data
str(data)
pars.save <- c("diff", "prob", "oneminusprob")
n.chains = 3
max.run = 100000
setsize = 10000
n.run = 50000
conv.limit = 1.05
samples <- jags.fit(network, data, pars.save, inits = NULL, n.chains, max.run, setsize, n.run, conv.limit)
mod = rjags::jags.model(textConnection(network$code), data = data, inits = inits, n.chains = n.chains, n.adapt = 0)
adapted <- FALSE
count <- 0
while(!adapted){
adapted <- rjags::adapt(mod, setsize, end.adaptation = FALSE)
count <- count + 1
if(count == 100){
stop("algorithm has not adapted")
}
}
samples <- rjags::coda.samples(model = mod, variable.names = pars.save, n.iter = setsize)
summary(samples)
varnames <- dimnames(samples[[1]])[[2]]
varnames.split <- sapply(strsplit(varnames, "\\["), '[[', 1)
conv.save.variables <- varnames.split %in% conv.save
max.gelman <- find.max.gelman(samples, conv.save.variables)
conv.save <- pars.save
varnames <- dimnames(samples[[1]])[[2]]
varnames.split <- sapply(strsplit(varnames, "\\["), '[[', 1)
conv.save.variables <- varnames.split %in% conv.save
max.gelman <- find.max.gelman(samples, conv.save.variables)
print(max.gelman)
check <- max.gelman > conv.limit
if(check) {
count <- 1
while (check & count < max.run/setsize) {
samples2 <- rjags::coda.samples(mod, variable.names = pars.save, n.iter = setsize)
samples <- add.mcmc(samples, samples2)
count <- count + 1
max.gelman <- find.max.gelman(samples, conv.save.variables)
check <- max.gelman > conv.limit
print(max.gelman)
}
}
start <- mcpar(samples[[1]])[1]
end <- mcpar(samples[[1]])[2]
mid <- (end + start-1)/2
burnin <- ceiling(end - mid)
samples <- window(samples, mid+1, end, 1) #keep the last half of the converged sequence
samples <- new.mcmc(samples)
n.thin <- 1
if(check == TRUE){
print("code didn't converge according to gelman-rubin diagnostics")
} else if(n.run < burnin){
n.thin <- ceiling(burnin/n.run)
extra.run <- n.run * n.thin - burnin
if(extra.run != 0){
samples2 <- rjags::coda.samples(mod, variable.names = pars.save, n.iter = extra.run)
samples <- add.mcmc(samples, samples2)
}
samples <- window(samples, 1, dim(samples[[1]])[1], n.thin)
} else if(n.run > burnin){
extra.run <- n.run - burnin
samples2 <- rjags::coda.samples(mod, variable.names = pars.save, n.iter = extra.run)
samples <- add.mcmc(samples, samples2)
}
max.gelman <- find.max.gelman(samples, conv.save.variables)
print(max.gelman)
result <- list(network = network, data.rjags = data, inits = inits, pars.save = pars.save)
result <- c(result, samples)
result
str(result)
samples <- jags.fit(network, data, pars.save, inits = NULL, n.chains, max.run, setsize, n.run, conv.limit)
mod = rjags::jags.model(textConnection(network$code), data = data, inits = inits, n.chains = n.chains, n.adapt = 0)
adapted <- FALSE
count <- 0
while(!adapted){
adapted <- rjags::adapt(mod, setsize, end.adaptation = FALSE)
count <- count + 1
if(count == 100){
stop("algorithm has not adapted")
}
}
if(class(network) == "network.data"){
conv.save <- if(network$response == "multinomial"){
c("d", "Eta", "sigma_transformed")
} else if(network$response == "binomial" || network$response == "normal"){
c("d", "Eta", "logvar")
}
if(network$type == "fixed"){
conv.save <- conv.save[!conv.save %in% c("logvar", "sigma_transformed")]
}
} else if(class(network) == "contrast.network.data" || class(network) == "ume.network.data" || class(network) == "nodesplit.network.data"){
conv.save <- pars.save
}
samples <- rjags::coda.samples(model = mod, variable.names = pars.save, n.iter = setsize)
varnames <- dimnames(samples[[1]])[[2]]
varnames.split <- sapply(strsplit(varnames, "\\["), '[[', 1)
conv.save.variables <- varnames.split %in% conv.save
max.gelman <- find.max.gelman(samples, conv.save.variables)
print(max.gelman)
check <- max.gelman > conv.limit
if(check) {
count <- 1
while (check & count < max.run/setsize) {
samples2 <- rjags::coda.samples(mod, variable.names = pars.save, n.iter = setsize)
samples <- add.mcmc(samples, samples2)
count <- count + 1
max.gelman <- find.max.gelman(samples, conv.save.variables)
check <- max.gelman > conv.limit
print(max.gelman)
}
}
class(network)
mod = rjags::jags.model(textConnection(network$code), data = data, inits = inits, n.chains = n.chains, n.adapt = 0)
adapted <- FALSE
count <- 0
while(!adapted){
adapted <- rjags::adapt(mod, setsize, end.adaptation = FALSE)
count <- count + 1
if(count == 100){
stop("algorithm has not adapted")
}
}
if(class(network) == "network.data"){
conv.save <- if(network$response == "multinomial"){
c("d", "Eta", "sigma_transformed")
} else if(network$response == "binomial" || network$response == "normal"){
c("d", "Eta", "logvar")
}
if(network$type == "fixed"){
conv.save <- conv.save[!conv.save %in% c("logvar", "sigma_transformed")]
}
} else if(class(network) == "contrast.network.data" || class(network) == "ume.network.data" || class(network) == "nodesplit.network.data"){
conv.save <- pars.save
}
samples <- rjags::coda.samples(model = mod, variable.names = pars.save, n.iter = setsize)
varnames <- dimnames(samples[[1]])[[2]]
varnames.split <- sapply(strsplit(varnames, "\\["), '[[', 1)
conv.save.variables <- varnames.split %in% conv.save
max.gelman <- find.max.gelman(samples, conv.save.variables)
samples
summary(samples)
find.max.gelman(samples, conv.save.variables)
dim(samples[[1]])
dim(samples[[2]])
dim(samples[[3]])
conv.save.variables
help(find.max.gelman)
find.max.gelman
lapply(samples2, function(x) { x[,colSums(abs(x)) != 0] })
find.max.gelman
samples2 <- lapply(samples, function(x){ x[,index]})
samples2 <- lapply(samples, function(x){ x[,c(TRUE, TRUE, TRUE)]})
samples2 <- lapply(samples2, function(x) { x[,colSums(abs(x)) != 0] })
str(samples2)
samples[[3]][,3]
mean(samples[[3]][,3])
mean(samples[[3]][,2])
mod = rjags::jags.model(textConnection(network$code), data = data, inits = inits, n.chains = n.chains, n.adapt = 0)
adapted <- FALSE
count <- 0
while(!adapted){
adapted <- rjags::adapt(mod, setsize, end.adaptation = FALSE)
count <- count + 1
if(count == 100){
stop("algorithm has not adapted")
}
}
if(class(network) == "network.data"){
conv.save <- if(network$response == "multinomial"){
c("d", "Eta", "sigma_transformed")
} else if(network$response == "binomial" || network$response == "normal"){
c("d", "Eta", "logvar")
}
if(network$type == "fixed"){
conv.save <- conv.save[!conv.save %in% c("logvar", "sigma_transformed")]
}
} else if(class(network) == "contrast.network.data" || class(network) == "ume.network.data"){
conv.save <- pars.save
} else if(class(network) == "nodesplit.network.data"){
conv.save <- "diff"
}
samples <- rjags::coda.samples(model = mod, variable.names = pars.save, n.iter = setsize)
varnames <- dimnames(samples[[1]])[[2]]
varnames.split <- sapply(strsplit(varnames, "\\["), '[[', 1)
conv.save.variables <- varnames.split %in% conv.save
max.gelman <- find.max.gelman(samples, conv.save.variables)
find.max.gelman
samples2 <- lapply(samples, function(x){ x[,index]})
samples2 <- lapply(samples, function(x){ x[,c(TRUE, TRUE, TRUE)]})
lapply(samples2, function(x) { x[,colSums(abs(x)) != 0] })
samples2 <- lapply(samples, function(x){ x[,c(TRUE, FALSE, FALSE)]})
find.max.gelman
lapply(samples2, function(x) { x[,colSums(abs(x)) != 0] })
pars.save <- c("direct","d", "sd", "diff", "prob", "oneminusprob")
mod = rjags::jags.model(textConnection(network$code), data = data, inits = inits, n.chains = n.chains, n.adapt = 0)
adapted <- FALSE
count <- 0
while(!adapted){
adapted <- rjags::adapt(mod, setsize, end.adaptation = FALSE)
count <- count + 1
if(count == 100){
stop("algorithm has not adapted")
}
}
if(class(network) == "network.data"){
conv.save <- if(network$response == "multinomial"){
c("d", "Eta", "sigma_transformed")
} else if(network$response == "binomial" || network$response == "normal"){
c("d", "Eta", "logvar")
}
if(network$type == "fixed"){
conv.save <- conv.save[!conv.save %in% c("logvar", "sigma_transformed")]
}
} else if(class(network) == "contrast.network.data" || class(network) == "ume.network.data"){
conv.save <- pars.save
} else if(class(network) == "nodesplit.network.data"){
conv.save <- c("direct","d", "sd", "diff")
}
samples <- rjags::coda.samples(model = mod, variable.names = pars.save, n.iter = setsize)
varnames <- dimnames(samples[[1]])[[2]]
varnames.split <- sapply(strsplit(varnames, "\\["), '[[', 1)
conv.save.variables <- varnames.split %in% conv.save
max.gelman <- find.max.gelman(samples, conv.save.variables)
print(max.gelman)
check <- max.gelman > conv.limit
mod = rjags::jags.model(textConnection(network$code), data = data, inits = inits, n.chains = n.chains, n.adapt = 0)
adapted <- FALSE
count <- 0
while(!adapted){
adapted <- rjags::adapt(mod, setsize, end.adaptation = FALSE)
count <- count + 1
if(count == 100){
stop("algorithm has not adapted")
}
}
if(class(network) == "network.data"){
conv.save <- if(network$response == "multinomial"){
c("d", "Eta", "sigma_transformed")
} else if(network$response == "binomial" || network$response == "normal"){
c("d", "Eta", "logvar")
}
if(network$type == "fixed"){
conv.save <- conv.save[!conv.save %in% c("logvar", "sigma_transformed")]
}
} else if(class(network) == "contrast.network.data" || class(network) == "ume.network.data"){
conv.save <- pars.save
} else if(class(network) == "nodesplit.network.data"){
conv.save <- c("direct","d", "sd", "diff")
}
samples <- rjags::coda.samples(model = mod, variable.names = pars.save, n.iter = setsize)
varnames <- dimnames(samples[[1]])[[2]]
varnames.split <- sapply(strsplit(varnames, "\\["), '[[', 1)
conv.save.variables <- varnames.split %in% conv.save
max.gelman <- find.max.gelman(samples, conv.save.variables)
print(max.gelman)
check <- max.gelman > conv.limit
devtools::install_github("MikeJSeo/bnma")
library(bnma)
nodesplit.network.run()
nodesplit.network.run
network <- with(thrombolytic, nodesplit.network.data(Outcomes, Study, Treat, N, response = "binomial", pair = c(3,9)))
result <- nodesplit.network.run(network)
summary(result)
# load packages needed
library(MASS) # Used for data simulation
library(lme4) #for fitting glmm
library(glmnet) #for lasso
library(glmmLasso) #for glmmLasso
library(dclone) # for parallel processing of JAGS code
library(knitr) # for tables
library(nlme) # for initial values for glmmLasso
setwd("C:/Users/mike/Desktop/Github/phd/varselect")
source("run.simulation.functions.R")
source("helpful.functions.R")
# setup for parallel computing
n.cores <- 2
cl <- makePSOCKcluster(n.cores)
tmp <- clusterEvalQ(cl, library(dclone))
# number of simulation to run
niter <- 1000
set.seed(i)
data <-generate.simulation(Nstudies = Nstudies, Ncovariate = Ncovariate, continuous.cov = continuous.cov, pf = pf, em = em, b1 = b1, b2 = b2, model.type = model.type)
source("run.simulation.functions.R")
source("helpful.functions.R")
setwd("~/GitHub/phd/varselect")
source("run.simulation.functions.R")
source("helpful.functions.R")
set.seed(i)
data <-generate.simulation(Nstudies = Nstudies, Ncovariate = Ncovariate, continuous.cov = continuous.cov, pf = pf, em = em, b1 = b1, b2 = b2, model.type = model.type)
col_labels <- c(paste0("X", 1:10, ":treat"), "treat")
col_labels_glmmLasso <- c(paste0("X", 1:10, "_treat"), "treat")
correct_em <- c(0, 0, 0, 1, 1, 0, 0, 0, 0, 0)
correct_em_values <- c(0, 0, 0, 0.3, 0.5, 0, 0, 0, 0, 0)
Nstudies <- 5
Ncovariate <- 10
continuous.cov <- c(1, 2, 4, 6, 7, 8)
pf <- c(1,2,3,4,5)
em <- c(4,5)
b1 <- c(0.1, 0.1, 0.5, 0.3, 0.5)
b2 <- c(0.3, 0.5)
glmm_oracle_formula <- as.formula("y ~ studyid + X1 + X2 + X3 + X4 + X5 + X4 * treat + X5 * treat + treat + (-1 + treat|studyid)")
glmm_full_formula <- as.formula("y ~ studyid + (X1 + X2 + X3 + X4 + X5 + X6 + X7 + X8 + X9 + X10)*treat + (-1 + treat|studyid)")
step_full_formula <-  as.formula("y ~ studyid + (X1 + X2 + X3 + X4 + X5 + X6 + X7 + X8 + X9 + X10)*treat")
glmmLasso_formula <- as.formula("y ~ as.factor(studyid) + X1 + X2 + X3 + X4 + X5 + X6 + X7 + X8 + X9 + X10 + X1_treat + X2_treat + X3_treat + X4_treat + X5_treat + X6_treat + X7_treat + X8_treat + X9_treat + X10_treat + treat")
model.type = "gaussian"
set.seed(i)
data <-generate.simulation(Nstudies = Nstudies, Ncovariate = Ncovariate, continuous.cov = continuous.cov, pf = pf, em = em, b1 = b1, b2 = b2, model.type = model.type)
install.packages("glinternet")
library("glinternet")
Y = rnorm(100)
X = matrix(rnorm(100*10), nrow=100)
numLevels = rep(1, 10)
fit = glinternet(X, Y, numLevels)
coeffs = coef(fit)
data <-generate.simulation(Nstudies = Nstudies, Ncovariate = Ncovariate, continuous.cov = continuous.cov, pf = pf, em = em, b1 = b1, b2 = b2, model.type = model.type)
data_glmnet <- model.matrix(step_full_formula, data = data)
data_glmnet <- data_glmnet[,-1]
data_glmnet <- cbind(y = data$y, data_glmnet = data_glmnet)
help(glinternet)
X
