source("run.simulation.functions.R")
source("helpful.functions.R")
# setup for parallel computing
n.cores <- 2
cl <- makePSOCKcluster(n.cores)
tmp <- clusterEvalQ(cl, library(dclone))
# number of simulation to run
niter <- 1
# load packages needed
library(MASS) # Used for data simulation
library(lme4) #for fitting glmm
library(glmnet) #for lasso
library(glmmLasso) #for glmmLasso
library(dclone) # for parallel processing of JAGS code
library(knitr) # for tables
library(nlme) # for initial values for glmmLasso
# Setting directory
#setwd("C:/Users/ms19g661/Desktop")
setwd("C:/Users/mike/Desktop")
#load/save everything else from/to github
#setwd("~/GitHub/phd/varselect")
setwd("C:/Users/mike/Desktop/Github/phd/varselect")
source("run.simulation.functions.R")
source("helpful.functions.R")
# setup for parallel computing
n.cores <- 2
cl <- makePSOCKcluster(n.cores)
tmp <- clusterEvalQ(cl, library(dclone))
# number of simulation to run
niter <- 1
# Setting directory
setwd("C:/Users/ms19g661/Desktop")
#setwd("C:/Users/mike/Desktop")
#load/save everything else from/to github
setwd("~/GitHub/phd/varselect")
#setwd("C:/Users/mike/Desktop/Github/phd/varselect")
source("run.simulation.functions.R")
source("helpful.functions.R")
# setup for parallel computing
n.cores <- 2
cl <- makePSOCKcluster(n.cores)
tmp <- clusterEvalQ(cl, library(dclone))
# number of simulation to run
niter <- 1
col_labels_glmm <- c(paste0("treat:", "X", 1:5), "treat")
col_labels <- c(paste0("X", 1:5, ":treat"), "treat")
col_labels_glmmLasso <- c(paste0("X", 1:5, "_treat"), "treat")
correct_em <- c(0, 0, 1, 0, 0)
correct_em_values <- c(0, 0, 0.1, 0, 0)
Nstudies <- 5
Ncovariate <- 5
continuous.cov <- c(1, 3, 4)
pf <- c(1,2,3)
em <- 3
b1 <- c(0.1, 0.5, 0.1)
b2 <- 0.1
glmm_null_formula <- as.formula("y ~ studyid + treat + (-1 + treat|studyid)")
glmm_full_formula <- as.formula("y ~ studyid + treat + (X1 + X2 + X3 + X4 + X5)*treat + (-1 + treat|studyid)")
step_full_formula <-  as.formula("y ~ (X1 + X2 + X3 + X4 + X5)*treat")
glmmLasso_formula <- as.formula("y ~ as.factor(studyid) + X1 + X2 + X3 + X4 + X5 + X1_treat + X2_treat + X3_treat + X4_treat + X5_treat + treat")
model.type = "gaussian"
i = 1
set.seed(i)
data <-generate.simulation(Nstudies = Nstudies, Ncovariate = Ncovariate, continuous.cov = continuous.cov, pf = pf, em = em, b1 = b1, b2 = b2)
if(model.type == "gaussian"){
PQL <-glmmPQL(step_full_formula, random = ~ -1 + treat|studyid, family=gaussian, data=data)
}
q_start <- as.numeric(VarCorr(PQL)[1,1])
start <- as.numeric(c(PQL$coef$fixed[-which(names(PQL$coef$fixed) == "treat")], PQL$coef$fixed[which(names(PQL$coef$fixed) == "treat")], t(PQL$coef$random$studyid)))
colnames(data) <- gsub(":", "_", colnames(data)) #glmmLasso doesn't allow colon sign
form.fixed <- glmmLasso_formula
form.rnd <- list(studyid =~ -1 + treat)
if(model.type == "gaussian") {
cv.fit <- cv.glmmLasso(data, form.fixed = form.fixed, form.rnd = form.rnd, lambda = seq(100, 0, by = -5), family = gaussian(link="identity"), q_start = q_start, start = start)
}
aa <- summary(cv.fit[[1]])$coefficients
aa <- rownames(aa[aa[,"Estimate"] != 0,])
mean_values <- sapply(col_labels_glmmLasso, function(x) ifelse(x %in% aa, summary(cv.fit[[1]])$coefficients[x,"Estimate"], 0))
sd_values <- bootstrap_function_glmmLasso(data, 100, cv.fit[[2]], model.type, form.fixed, form.rnd)
cv.fi
cv.fit
start
cv.glmmLasso(data, form.fixed = form.fixed, form.rnd = form.rnd, lambda = seq(100, 0, by = -5), family = gaussian(link="identity"), q_start = q_start, start = start)
PQL
Nstudies
start <- as.numeric(c(PQL$coef$fixed[-which(names(PQL$coef$fixed) == "treat")], PQL$coef$fixed[which(names(PQL$coef$fixed) == "treat")], t(PQL$coef$random$studyid)))
start
form.fixed
form.rnd
q_start
start
PQL$coef$random$studyid
PQL$coef$fixed
pql_formula <- s.formula("y ~ studyid + (X1 + X2 + X3 + X4 + X5)*treat")
set.seed(i)
data <-generate.simulation(Nstudies = Nstudies, Ncovariate = Ncovariate, continuous.cov = continuous.cov, pf = pf, em = em, b1 = b1, b2 = b2)
if(model.type == "gaussian"){
PQL <-glmmPQL(pql_formula, random = ~ -1 + treat|studyid, family=gaussian, data=data)
}
q_start <- as.numeric(VarCorr(PQL)[1,1])
start <- as.numeric(c(PQL$coef$fixed[-which(names(PQL$coef$fixed) == "treat")], PQL$coef$fixed[which(names(PQL$coef$fixed) == "treat")], t(PQL$coef$random$studyid)))
colnames(data) <- gsub(":", "_", colnames(data)) #glmmLasso doesn't allow colon sign
form.fixed <- glmmLasso_formula
form.rnd <- list(studyid =~ -1 + treat)
if(model.type == "gaussian") {
cv.fit <- cv.glmmLasso(data, form.fixed = form.fixed, form.rnd = form.rnd, lambda = seq(100, 0, by = -5), family = gaussian(link="identity"), q_start = q_start, start = start)
}
cv.fit
PQL <-glmmPQL(pql_formula, random = ~ -1 + treat|studyid, family=gaussian, data=data)
pql_formula <- s.formula("y ~ studyid + (X1 + X2 + X3 + X4 + X5)*treat")
pql_formula <- as.formula("y ~ studyid + (X1 + X2 + X3 + X4 + X5)*treat")
set.seed(i)
data <-generate.simulation(Nstudies = Nstudies, Ncovariate = Ncovariate, continuous.cov = continuous.cov, pf = pf, em = em, b1 = b1, b2 = b2)
if(model.type == "gaussian"){
PQL <-glmmPQL(pql_formula, random = ~ -1 + treat|studyid, family=gaussian, data=data)
}
q_start <- as.numeric(VarCorr(PQL)[1,1])
start <- as.numeric(c(PQL$coef$fixed[-which(names(PQL$coef$fixed) == "treat")], PQL$coef$fixed[which(names(PQL$coef$fixed) == "treat")], t(PQL$coef$random$studyid)))
colnames(data) <- gsub(":", "_", colnames(data)) #glmmLasso doesn't allow colon sign
form.fixed <- glmmLasso_formula
form.rnd <- list(studyid =~ -1 + treat)
if(model.type == "gaussian") {
cv.fit <- cv.glmmLasso(data, form.fixed = form.fixed, form.rnd = form.rnd, lambda = seq(100, 0, by = -5), family = gaussian(link="identity"), q_start = q_start, start = start)
}
cv.fit
## code to do cross validation for glmmLasso to get optimal lambda value
cv.glmmLasso <- function(data_glmmLasso, form.fixed = NULL, form.rnd = NULL, lambda = NULL, family = NULL, q_start, start){
N <-dim(data_glmmLasso)[1]
ind<-sample(N,N)
kk <- 5 # 5 fold cross-validation
nk <- floor(N/kk)
Devianz_ma<-matrix(Inf,ncol=kk,nrow=length(lambda))
if(length(lambda) >1 ){
for(j in 1:length(lambda)){
print(paste("Iteration ", j,sep=""))
for (i in 1:kk)
{
if (i < kk){
indi <- ind[(i-1)*nk+(1:nk)]
} else{
indi <- ind[((i-1)*nk+1):N]
}
data_glmmLasso_train <- data_glmmLasso[-indi,]
data_glmmLasso_test <- data_glmmLasso[indi,]
glm2 <- try(glmmLasso(form.fixed, rnd = form.rnd,
family = family,
lambda = lambda[j],
switch.NR = TRUE,
data = data_glmmLasso_train,
control = list(index = c(NA, 1:((dim(data_glmmLasso)[2] - 3)), NA), q_start = q_start, start = start))
,silent=TRUE)
if(class(glm2)!="try-error")
{
y.hat<-predict(glm2,data_glmmLasso_test)
Devianz_ma[j,i]<-sum(family$dev.resids(data_glmmLasso_test$y,y.hat,wt=rep(1,length(y.hat))))
}
}
}
Devianz_vec<-apply(Devianz_ma,1,sum)
opt2<-which.min(Devianz_vec)
#print(Devianz_vec)
#print(paste0("optimal lambda value is ", lambda[opt2]))
lambda.min <- lambda[opt2]
} else{
lambda.min <- lambda
}
glm2 <- try(glmmLasso(form.fixed, rnd = form.rnd,
family = family,
lambda = lambda.min,
switch.NR = TRUE,
data = data_glmmLasso,
control = list(index = c(NA, 1:((dim(data_glmmLasso)[2] - 3)), NA), q_start = q_start, start = start))
,silent=TRUE)
list(glm2 = glm2, lambda.min = lambda.min)
}
if(model.type == "gaussian") {
cv.fit <- cv.glmmLasso(data, form.fixed = form.fixed, form.rnd = form.rnd, lambda = seq(100, 0, by = -5), family = gaussian(link="identity"), q_start = q_start, start = start)
}
cv.fit
## code to do cross validation for glmmLasso to get optimal lambda value
cv.glmmLasso <- function(data_glmmLasso, form.fixed = NULL, form.rnd = NULL, lambda = NULL, family = NULL, q_start, start){
N <-dim(data_glmmLasso)[1]
ind<-sample(N,N)
kk <- 5 # 5 fold cross-validation
nk <- floor(N/kk)
Devianz_ma<-matrix(Inf,ncol=kk,nrow=length(lambda))
if(length(lambda) >1 ){
for(j in 1:length(lambda)){
print(paste("Iteration ", j,sep=""))
for (i in 1:kk)
{
if (i < kk){
indi <- ind[(i-1)*nk+(1:nk)]
} else{
indi <- ind[((i-1)*nk+1):N]
}
data_glmmLasso_train <- data_glmmLasso[-indi,]
data_glmmLasso_test <- data_glmmLasso[indi,]
glm2 <- try(glmmLasso(form.fixed, rnd = form.rnd,
family = family,
lambda = lambda[j],
data = data_glmmLasso_train,
control = list(index = c(NA, 1:((dim(data_glmmLasso)[2] - 3)), NA), q_start = q_start, start = start))
,silent=TRUE)
if(class(glm2)!="try-error")
{
y.hat<-predict(glm2,data_glmmLasso_test)
Devianz_ma[j,i]<-sum(family$dev.resids(data_glmmLasso_test$y,y.hat,wt=rep(1,length(y.hat))))
}
}
}
Devianz_vec<-apply(Devianz_ma,1,sum)
opt2<-which.min(Devianz_vec)
#print(Devianz_vec)
#print(paste0("optimal lambda value is ", lambda[opt2]))
lambda.min <- lambda[opt2]
} else{
lambda.min <- lambda
}
glm2 <- try(glmmLasso(form.fixed, rnd = form.rnd,
family = family,
lambda = lambda.min,
data = data_glmmLasso,
control = list(index = c(NA, 1:((dim(data_glmmLasso)[2] - 3)), NA), q_start = q_start, start = start))
,silent=TRUE)
list(glm2 = glm2, lambda.min = lambda.min)
}
if(model.type == "gaussian") {
cv.fit <- cv.glmmLasso(data, form.fixed = form.fixed, form.rnd = form.rnd, lambda = seq(100, 0, by = -5), family = gaussian(link="identity"), q_start = q_start, start = start)
}
cv.fit
set.seed(i)
data <-generate.simulation(Nstudies = Nstudies, Ncovariate = Ncovariate, continuous.cov = continuous.cov, pf = pf, em = em, b1 = b1, b2 = b2)
if(model.type == "gaussian"){
PQL <-glmmPQL(pql_formula, random = ~ -1 + treat|studyid, family=gaussian, data=data)
}
q_start <- as.numeric(VarCorr(PQL)[1,1])
start <- as.numeric(c(PQL$coef$fixed[-which(names(PQL$coef$fixed) == "treat")], PQL$coef$fixed[which(names(PQL$coef$fixed) == "treat")], t(PQL$coef$random$studyid)))
colnames(data) <- gsub(":", "_", colnames(data)) #glmmLasso doesn't allow colon sign
form.fixed <- glmmLasso_formula
form.rnd <- list(studyid =~ -1 + treat)
if(model.type == "gaussian") {
cv.fit <- cv.glmmLasso(data, form.fixed = form.fixed, form.rnd = form.rnd, lambda = seq(100, 0, by = -5), family = gaussian(link="identity"), q_start = q_start, start = start)
}
aa <- summary(cv.fit[[1]])$coefficients
aa <- rownames(aa[aa[,"Estimate"] != 0,])
aa
mean_values <- sapply(col_labels_glmmLasso, function(x) ifelse(x %in% aa, summary(cv.fit[[1]])$coefficients[x,"Estimate"], 0))
sd_values <- bootstrap_function_glmmLasso(data, 100, cv.fit[[2]], model.type, form.fixed, form.rnd, q_start = q_start, start = start)
bootstrap_function_glmmLasso  <- function(model_data, ndraws, lambda.min = NULL, model.type = NULL, form.fixed, form.rnd, q_start, start) {
if(is.null(model.type)) stop("model type missing")
coeff_mtx <- matrix(0, nrow = ndraws, ncol = length(col_labels))
for (ii in 1:ndraws) {
print(form.fixed)
print(form.rnd)
bootstrap_ids <- sample(seq(nrow(model_data)), nrow(model_data), replace = TRUE)
bootstrap_data <- model_data[bootstrap_ids,]
if(model.type == "gaussian"){
bootstrap_model <- cv.glmmLasso(bootstrap_data, form.fixed = form.fixed, form.rnd = form.rnd, lambda = lambda.min, family = gaussian(link="identity"), q_start = q_start, start = start)
}
print(bootstrap_model)
aa <- summary(bootstrap_model[[1]])$coefficients
aa <- rownames(aa[aa[,"Estimate"] != 0,])
coeff_mtx[ii,] <- sapply(col_labels_glmmLasso, function(x) ifelse(x %in% aa, summary(bootstrap_model[[1]])$coefficients[x,"Estimate"], 0))
}
se <- apply(coeff_mtx, 2, sd, na.rm = TRUE)
return(se)
}
bootstrap_function_glmmLasso  <- function(model_data, ndraws, lambda.min = NULL, model.type = NULL, form.fixed, form.rnd, q_start, start) {
if(is.null(model.type)) stop("model type missing")
coeff_mtx <- matrix(0, nrow = ndraws, ncol = length(col_labels))
for (ii in 1:ndraws) {
print(form.fixed)
print(form.rnd)
bootstrap_ids <- sample(seq(nrow(model_data)), nrow(model_data), replace = TRUE)
bootstrap_data <- model_data[bootstrap_ids,]
if(model.type == "gaussian"){
bootstrap_model <- cv.glmmLasso(bootstrap_data, form.fixed = form.fixed, form.rnd = form.rnd, lambda = lambda.min, family = gaussian(link="identity"), q_start = q_start, start = start)
}
print(bootstrap_model)
aa <- summary(bootstrap_model[[1]])$coefficients
aa <- rownames(aa[aa[,"Estimate"] != 0,])
coeff_mtx[ii,] <- sapply(col_labels_glmmLasso, function(x) ifelse(x %in% aa, summary(bootstrap_model[[1]])$coefficients[x,"Estimate"], 0))
}
se <- apply(coeff_mtx, 2, sd, na.rm = TRUE)
return(se)
}
mean_values <- sapply(col_labels_glmmLasso, function(x) ifelse(x %in% aa, summary(cv.fit[[1]])$coefficients[x,"Estimate"], 0))
sd_values <- bootstrap_function_glmmLasso(data, 100, cv.fit[[2]], model.type, form.fixed, form.rnd, q_start = q_start, start = start)
bootstrap_function_glmmLasso  <- function(model_data, ndraws, lambda.min = NULL, model.type = NULL, form.fixed, form.rnd, q_start, start) {
if(is.null(model.type)) stop("model type missing")
coeff_mtx <- matrix(0, nrow = ndraws, ncol = length(col_labels))
for (ii in 1:ndraws) {
if(ii % 100 == 0) {
print(paste0("iteration ", ii))
}
bootstrap_ids <- sample(seq(nrow(model_data)), nrow(model_data), replace = TRUE)
bootstrap_data <- model_data[bootstrap_ids,]
if(model.type == "gaussian"){
bootstrap_model <- cv.glmmLasso(bootstrap_data, form.fixed = form.fixed, form.rnd = form.rnd, lambda = lambda.min, family = gaussian(link="identity"), q_start = q_start, start = start)
}
print(bootstrap_model)
aa <- summary(bootstrap_model[[1]])$coefficients
aa <- rownames(aa[aa[,"Estimate"] != 0,])
coeff_mtx[ii,] <- sapply(col_labels_glmmLasso, function(x) ifelse(x %in% aa, summary(bootstrap_model[[1]])$coefficients[x,"Estimate"], 0))
}
se <- apply(coeff_mtx, 2, sd, na.rm = TRUE)
return(se)
}
bootstrap_function_glmmLasso  <- function(model_data, ndraws, lambda.min = NULL, model.type = NULL, form.fixed, form.rnd, q_start, start) {
if(is.null(model.type)) stop("model type missing")
coeff_mtx <- matrix(0, nrow = ndraws, ncol = length(col_labels))
for (ii in 1:ndraws) {
if(ii % 100 == 0) {
print(paste0("iteration ", ii))
}
bootstrap_ids <- sample(seq(nrow(model_data)), nrow(model_data), replace = TRUE)
bootstrap_data <- model_data[bootstrap_ids,]
if(model.type == "gaussian"){
bootstrap_model <- cv.glmmLasso(bootstrap_data, form.fixed = form.fixed, form.rnd = form.rnd, lambda = lambda.min, family = gaussian(link="identity"), q_start = q_start, start = start)
}
print(bootstrap_model)
aa <- summary(bootstrap_model[[1]])$coefficients
aa <- rownames(aa[aa[,"Estimate"] != 0,])
coeff_mtx[ii,] <- sapply(col_labels_glmmLasso, function(x) ifelse(x %in% aa, summary(bootstrap_model[[1]])$coefficients[x,"Estimate"], 0))
}
se <- apply(coeff_mtx, 2, sd, na.rm = TRUE)
return(se)
}
55 % 100
55 %% 100
bootstrap_function_glmmLasso  <- function(model_data, ndraws, lambda.min = NULL, model.type = NULL, form.fixed, form.rnd, q_start, start) {
if(is.null(model.type)) stop("model type missing")
coeff_mtx <- matrix(0, nrow = ndraws, ncol = length(col_labels))
for (ii in 1:ndraws) {
if(ii %% 100 == 0) {
print(paste0("iteration ", ii))
}
bootstrap_ids <- sample(seq(nrow(model_data)), nrow(model_data), replace = TRUE)
bootstrap_data <- model_data[bootstrap_ids,]
if(model.type == "gaussian"){
bootstrap_model <- cv.glmmLasso(bootstrap_data, form.fixed = form.fixed, form.rnd = form.rnd, lambda = lambda.min, family = gaussian(link="identity"), q_start = q_start, start = start)
}
print(bootstrap_model)
aa <- summary(bootstrap_model[[1]])$coefficients
aa <- rownames(aa[aa[,"Estimate"] != 0,])
coeff_mtx[ii,] <- sapply(col_labels_glmmLasso, function(x) ifelse(x %in% aa, summary(bootstrap_model[[1]])$coefficients[x,"Estimate"], 0))
}
se <- apply(coeff_mtx, 2, sd, na.rm = TRUE)
return(se)
}
mean_values <- sapply(col_labels_glmmLasso, function(x) ifelse(x %in% aa, summary(cv.fit[[1]])$coefficients[x,"Estimate"], 0))
sd_values <- bootstrap_function_glmmLasso(data, 100, cv.fit[[2]], model.type, form.fixed, form.rnd, q_start = q_start, start = start)
bootstrap_function_glmmLasso  <- function(model_data, ndraws, lambda.min = NULL, model.type = NULL, form.fixed, form.rnd, q_start, start) {
if(is.null(model.type)) stop("model type missing")
coeff_mtx <- matrix(0, nrow = ndraws, ncol = length(col_labels))
for (ii in 1:ndraws) {
if(ii %% 100 == 0) {
print(paste0("iteration ", ii))
}
bootstrap_ids <- sample(seq(nrow(model_data)), nrow(model_data), replace = TRUE)
bootstrap_data <- model_data[bootstrap_ids,]
if(model.type == "gaussian"){
bootstrap_model <- cv.glmmLasso(bootstrap_data, form.fixed = form.fixed, form.rnd = form.rnd, lambda = lambda.min, family = gaussian(link="identity"), q_start = q_start, start = start)
}
aa <- summary(bootstrap_model[[1]])$coefficients
aa <- rownames(aa[aa[,"Estimate"] != 0,])
coeff_mtx[ii,] <- sapply(col_labels_glmmLasso, function(x) ifelse(x %in% aa, summary(bootstrap_model[[1]])$coefficients[x,"Estimate"], 0))
}
se <- apply(coeff_mtx, 2, sd, na.rm = TRUE)
return(se)
}
mean_values <- sapply(col_labels_glmmLasso, function(x) ifelse(x %in% aa, summary(cv.fit[[1]])$coefficients[x,"Estimate"], 0))
sd_values <- bootstrap_function_glmmLasso(data, 100, cv.fit[[2]], model.type, form.fixed, form.rnd, q_start = q_start, start = start)
sd_values
mean_values
find_performance(mean_values, correct_em_values, correct_em)
find_performance2(sd_values, correct_em, continuous.cov)
generate.simulatino
generate.simulatino
generate.simulation
set.seed(i)
data <-generate.simulation(Nstudies = Nstudies, Ncovariate = Ncovariate, continuous.cov = continuous.cov, pf = pf, em = em, b1 = b1, b2 = b2)
if(model.type == "gaussian"){
m1 <- lmer(glmm_null_formula, data = data)
}
glmm_null_formula
set.seed(i)
data <-generate.simulation(Nstudies = Nstudies, Ncovariate = Ncovariate, continuous.cov = continuous.cov, pf = pf, em = em, b1 = b1, b2 = b2)
if(model.type == "gaussian"){
m1 <- lmer(glmm_full_formula, data = data)
}
m1
ls(m1)
m1
lmer(treat:X2, data = data)
lmer("treat:X2", data = data)
lmer(y ~ treat:X2 + (-1 + treat | studyid), data = data)
mydata
data
help(lmer)
help(glmnet)
generate.simulation <- function(Nstudies = NULL, Ncovariate = NULL, continuous.cov = NULL, pf = NULL, em = NULL,
b1 = NULL, b2 = NULL, sampleSize = c(50, 100), model = "continuous"){
#treatment effect
d <- 1
sd <- 0.2
delta <- rnorm(Nstudies, d, sd)
studyid <- NULL
for(i in 1:Nstudies){
studyid <- c(studyid, rep(i, sample(sampleSize[1]:sampleSize[2], size = 1)))
}
#study baseline effect
alpha <- runif(Nstudies, -1, 1)
treat <- rbinom(length(studyid), 1, 0.5)
#generating data
rho <- 0.3
len <- length(continuous.cov)
cov_matrix <- matrix(NA, nrow = len, ncol = len)
for(ii in 1:len){
for(jj in 1:len){
cov_matrix[ii,jj] <- rho^abs(ii - jj)
}
}
X <- matrix(NA, nrow = length(studyid), ncol = Ncovariate)
for(i in 1:length(studyid)){
X[i,continuous.cov] <-  mvrnorm(n = 1, mu = rep(0, len), cov_matrix)
}
X[,-continuous.cov] <- rbinom(length(studyid)* (Ncovariate - length(continuous.cov)), 1, 0.5)
# standardize X
X <- apply(X, 2, scale)
data <- model.matrix(~ -1 +  X*treat)
meany <- alpha[studyid] + delta[studyid] * treat + X[,pf, drop = FALSE] %*% b1 + X[,em, drop = FALSE] %*% b2 * treat
sigmay <- 0.5
py <- expit(meany)
if(model == "continuous"){
y <- rnorm(length(studyid), meany, sigmay)
} else if (model == "binomial"){
y <- rbinom(length(studyid), 1, py)
}
data <- cbind(y = y, data = data, studyid = studyid)
data <- as.data.frame(data)
data$studyid <- as.factor(data$studyid)
return(data)
}
set.seed(i)
data <-generate.simulation(Nstudies = Nstudies, Ncovariate = Ncovariate, continuous.cov = continuous.cov, pf = pf, em = em, b1 = b1, b2 = b2)
if(model.type == "gaussian"){
m1 <- lmer(glmm_null_formula, data = data)
}
generate.simulation <- function(Nstudies = NULL, Ncovariate = NULL, continuous.cov = NULL, pf = NULL, em = NULL,
b1 = NULL, b2 = NULL, sampleSize = c(50, 100), model = "continuous"){
#treatment effect
d <- 1
sd <- 0.2
delta <- rnorm(Nstudies, d, sd)
studyid <- NULL
for(i in 1:Nstudies){
studyid <- c(studyid, rep(i, sample(sampleSize[1]:sampleSize[2], size = 1)))
}
#study baseline effect
alpha <- runif(Nstudies, -1, 1)
treat <- rbinom(length(studyid), 1, 0.5)
#generating data
rho <- 0.3
len <- length(continuous.cov)
cov_matrix <- matrix(NA, nrow = len, ncol = len)
for(ii in 1:len){
for(jj in 1:len){
cov_matrix[ii,jj] <- rho^abs(ii - jj)
}
}
X <- matrix(NA, nrow = length(studyid), ncol = Ncovariate)
for(i in 1:length(studyid)){
X[i,continuous.cov] <-  mvrnorm(n = 1, mu = rep(0, len), cov_matrix)
}
X[,-continuous.cov] <- rbinom(length(studyid)* (Ncovariate - length(continuous.cov)), 1, 0.5)
# standardize X: binary and continuous variables in same scale
X <- apply(X, 2, scale)
data <- model.matrix(~ -1 +  X*treat)
meany <- alpha[studyid] + delta[studyid] * treat + X[,pf, drop = FALSE] %*% b1 + X[,em, drop = FALSE] %*% b2 * treat
sigmay <- 0.5
py <- expit(meany)
if(model == "continuous"){
y <- rnorm(length(studyid), meany, sigmay)
} else if (model == "binomial"){
y <- rbinom(length(studyid), 1, py)
}
data <- cbind(y = y, data = data, studyid = studyid)
data <- as.data.frame(data)
data$studyid <- as.factor(data$studyid)
return(data)
}
data <-generate.simulation(Nstudies = Nstudies, Ncovariate = Ncovariate, continuous.cov = continuous.cov, pf = pf, em = em, b1 = b1, b2 = b2)
if(model.type == "gaussian"){
m1 <- lmer(glmm_null_formula, data = data)
}
m1
summary(m1)
data <-generate.simulation(Nstudies = Nstudies, Ncovariate = Ncovariate, continuous.cov = continuous.cov, pf = pf, em = em, b1 = b1, b2 = b2)
if(model.type == "gaussian"){
m1 <- lmer(glmm_null_formula, data = data)
}
data <-generate.simulation(Nstudies = Nstudies, Ncovariate = Ncovariate, continuous.cov = continuous.cov, pf = pf, em = em, b1 = b1, b2 = b2)
if(model.type == "gaussian"){
m1 <- lmer(glmm_null_formula, data = data)
}
m1
data
sapply(data, mean)
data$y
help("glmmLasso")
