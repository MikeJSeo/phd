# imputation method - accounting for study level
imputationpred[[i]] <- NA
if(shrinkage == FALSE){
imputationpred[[i]] <- try(imputation_prediction(simulated_dataset, validation_dataset))
#imputationpred[[i]] <- try(imputation_prediction(simulated_dataset, validation_dataset, method = "imputation_2lglm"))
} else{
imputationpred[[i]] <- try(imputation_prediction(simulated_dataset, validation_dataset, shrinkage = TRUE))
}
# separate method
separatepred[[i]] <- NA
separatepred[[i]] <- try(separate_prediction(simulated_dataset, validation_dataset))
}
list(testdata = testdata, naivepred = naivepred, imputation_noclusterpred = imputation_noclusterpred,
imputationpred = imputationpred, separatepred = separatepred)
}
# From the calculated predictions, finds performance metrics
wrapper_function2 <- function(stored_predictions, aggregation = "ignore"){
Nsim <- length(stored_predictions$testdata)
naive_store <- matrix(NA, nrow = Nsim, ncol = 3)
imputation_noclusterstore <- matrix(NA, nrow = Nsim, ncol = 3)
imputation_store <- matrix(NA, nrow = Nsim, ncol = 3)
separate_store <- matrix(NA, nrow = Nsim, ncol = 3)
for(i in 1:Nsim){
testdata <- stored_predictions$testdata[[i]]
naivepred <- stored_predictions$naivepred[[i]]
imputation_noclusterpred <- stored_predictions$imputation_noclusterpred[[i]]
imputationpred <- stored_predictions$imputationpred[[i]]
separatepred <- stored_predictions$separatepred[[i]]
# naive method
naiveperf <- try(findPerformance(testdata, naivepred, aggregation = aggregation))
naive_store[i,] <- naiveperf
# imputation method - ignoring study level
imputation_noclusterperf <- try(findPerformance(testdata, imputation_noclusterpred, aggregation = aggregation))
imputation_noclusterstore[i,] <- imputation_noclusterperf
# imputation method - accounting for study level
imputationperf <- try(findPerformance(testdata, imputationpred, aggregation = aggregation))
imputation_store[i,] <- imputationperf
# separate method
separateperf <- try(findPerformance(testdata, separatepred, aggregation = aggregation))
separate_store[i,] <- separateperf
}
naive_store_revised <- apply(naive_store, 2, as.numeric)
imputation_noclusterstore_revised <- apply(imputation_noclusterstore, 2, as.numeric)
imputation_store_revised <- apply(imputation_store, 2, as.numeric)
separate_store_revised <- apply(separate_store, 2, as.numeric)
naive_failed <- which(rowSums(is.na(naive_store_revised)) > 0)
imputation_noclusterfailed <- which(rowSums(is.na(imputation_noclusterstore_revised)) > 0)
imputation_failed <- which(rowSums(is.na(imputation_store_revised)) > 0)
separate_failed <- which(rowSums(is.na(separate_store_revised)) > 0)
number_failed_simulations <- c(length(naive_failed), length(imputation_noclusterfailed),
length(imputation_failed), length(separate_failed))
# Set a threshold to exclude from comparison
threshold <- 20
if(length(imputation_failed) <= threshold){
failed_set <- unique(c(naive_failed, imputation_noclusterfailed, imputation_failed, separate_failed))
} else{
failed_set <- unique(c(naive_failed, imputation_noclusterfailed, separate_failed))
}
if(length(failed_set) != 0){
naive_store_revised <- naive_store_revised[-failed_set,]
imputation_noclusterstore_revised <- imputation_noclusterstore_revised[-failed_set,]
imputation_store_revised <- imputation_store_revised[-failed_set,]
separate_store_revised <- separate_store_revised[-failed_set,]
}
# return_matrix is the mean value; return_matrix2 is the Monte Carlo error
return_matrix <- return_matrix2 <- matrix(NA, 4, 3)
return_matrix[1,] <- round(apply(naive_store_revised, 2, mean, na.rm = TRUE), digits = 5)
return_matrix[2,] <- round(apply(imputation_noclusterstore_revised, 2, mean, na.rm = TRUE), digits = 5)
return_matrix2[1,] <- round(apply(naive_store_revised, 2, sd, na.rm = TRUE)/sqrt(length(naive_store_revised)), digits = 5)
return_matrix2[2,] <- round(apply(imputation_noclusterstore_revised, 2, sd, na.rm = TRUE)/ sqrt(length(imputation_noclusterstore_revised)), digits = 5)
if(length(imputation_failed) <= threshold){
return_matrix[3,] <- round(apply(imputation_store_revised, 2, mean, na.rm = TRUE), digits = 5)
return_matrix2[3,] <- round(apply(imputation_store_revised, 2, sd, na.rm = TRUE)/ sqrt(length(imputation_store_revised)), digits = 5)
}
return_matrix[4,] <- round(apply(separate_store_revised, 2, mean, na.rm = TRUE), digits = 5)
return_matrix2[4,] <- round(apply(separate_store_revised, 2, sd, na.rm = TRUE)/ sqrt(length(separate_store_revised)), digits = 5)
#only report MSE and R-squared
return_matrix <- return_matrix[,c(1,3)]
return_matrix2 <- return_matrix2[,c(1,3)]
rownames(return_matrix) <- rownames(return_matrix2) <- c("Naive", "Imputation ignoring heterogeneity", "Imputation accounting heterogeneity", "Separate prediction")
colnames(return_matrix) <- colnames(return_matrix2) <- c("MSE", "R-squared")
return(list(number_failed_simulations = number_failed_simulations, return_matrix = return_matrix, return_matrix2 = return_matrix2))
}
wrapper_function(Nstudies = 2, Ncov = 5, sys_missing_prob = 0.1, magnitude = NULL, heterogeneity = 0.3, Nsim = 1, shrinkage = TRUE, magnitude.complete = 0.2, magnitude.sys = 0.5)
# We changed name of the methods
# naive method -> restrict predictor method
# separate prediction method -> ensemble method
generate_sysmiss_ipdma_example_revised <- function(Nstudies = 10, Ncov = 5, sys_missing_prob = 0.1, magnitude = 0.3,
heterogeneity = 0.1, interaction = TRUE, magnitude.complete = NULL, magnitude.sys = NULL) {
Npatients <- sample(150:300, Nstudies, replace = TRUE)
Npatients.tot <- sum(Npatients)
study <- rep(1:Nstudies, times = Npatients)
a <- stats::runif(Nstudies, 0.5, 1.5)
a <- rep(a, times = Npatients)
### generate X
rho <- 0.2
Omega <- diag(1, Ncov)
for(i in 1:Ncov){
for(j in 1:Ncov){
Omega[i,j] <- rho^abs(i - j)
}
}
sigma2 <- 1
X <- NULL
for(i in 1:Nstudies){
mu <- stats::runif(Ncov, -1, 1)
X <- rbind(X, mvtnorm::rmvnorm(Npatients[i], mu, Omega * sigma2))
}
#categorize predictors
if(Ncov == 5){
X[,2] <- ifelse(X[,2] > 0, 1, 0)
X[,3] <- ifelse(X[,3] > 0.5, 1, 0)
} else if(Ncov == 10){
X[,2] <- ifelse(X[,2] > 0, 1, 0)
X[,3] <- ifelse(X[,3] > 0, 1, 0)
X[,8] <- ifelse(X[,8] > 0, 1, 0)
X[,9] <- ifelse(X[,9] > 0.5, 1, 0)
X[,10] <- ifelse(X[,10] > 0.5, 1, 0)
}
e_vec <- stats::rnorm(Npatients.tot, 0, 1)
b <- matrix(NA, Npatients.tot, Ncov)
#b[,1] <- rep(0.2, Npatients.tot)
for(i in 1:Ncov){
if(is.null(magnitude.complete)){
b_dummy <- stats::rnorm(Nstudies, magnitude, heterogeneity)
b_dummy <- rep(b_dummy, times = Npatients)
b[,i] <- b_dummy
} else{
magnitude <- ifelse(i %in% c(1,2), magnitude.complete, magnitude.sys)
b_dummy <- stats::rnorm(Nstudies, magnitude, heterogeneity)
b_dummy <- rep(b_dummy, times = Npatients)
b[,i] <- b_dummy
}
}
if(interaction == TRUE){
treat <- stats::rbinom(Npatients.tot, 1, 0.5)
Xinteraction <- X[,1:Ncov] * treat
cvec <- matrix(NA, Npatients.tot, Ncov)
for(i in 1:Ncov){
cvec_dummy <- stats::rnorm(Nstudies, magnitude/2, heterogeneity)
cvec_dummy <- rep(cvec_dummy, times = Npatients)
cvec[,i] <- cvec_dummy
}
d <- stats::rnorm(Nstudies, 1, 0.5)
d <- rep(d, times = Npatients)
}
if(interaction == FALSE){
y <- a + apply(X * b, 1, sum) + e_vec
} else if(interaction == TRUE){
y <- a + apply(X * b, 1, sum) + e_vec + d *treat + apply(Xinteraction * cvec, 1, sum)
}
# introduce systematically missing; first two predictors are always observed
for(j in 3:Ncov){
for(i in 1:Nstudies){
if(stats::rbinom(1, 1, sys_missing_prob) == 1){
X[study == i,j] <- NA
}
}
}
# Define dataset to return
dataset <- data.frame(y = y, X = X[,1:Ncov], study = study)
colnames(dataset) <- c("y", paste0("x", 1:Ncov), "study")
dataset <- as_tibble(dataset)
if(Ncov == 5){
dataset <- dataset %>% mutate(x2 = as.factor(x2),
x3 = as.factor(x3))
} else if(Ncov == 10){
dataset <- dataset %>% mutate(x2 = as.factor(x2),
x3 = as.factor(x3),
x8 = as.factor(x8),
x9 = as.factor(x9),
x10 = as.factor(x10)
)
}
dataset <- as_tibble(dataset)
if(interaction == TRUE){
dataset <- cbind(dataset, treat = treat)
dataset <- as_tibble(dataset)
} else if(interaction == FALSE){
dataset <- as_tibble(dataset)
}
return(dataset)
}
naive_prediction <- function(traindata, testdata, shrinkage = NULL){
if(is.null(shrinkage)){
shrinkage <- FALSE
}
nstudy <- length(unique(testdata$study))
predictions <- list()
#If the dataset contains treatment, it is assumed to have interaction terms as well
interaction <- "treat" %in% colnames(traindata)
covariates <- names(traindata)
covariates <- covariates[grepl("x", covariates)]
if(length(covariates) == 5){
typeofvar <- c("continuous", "binary", "binary", "continuous", "continuous")
names(typeofvar) <- paste0("x", 1:5)
} else if(length(covariates) == 10){
typeofvar <- c("continuous", "binary", "binary", "continuous", "continuous", "continuous", "continuous", "binary", "binary", "binary")
names(typeofvar) <- paste0("x", 1:10)
}
#Find missing data pattern such as systematically missing predictors, sporadically missing predictors
missingPattern <- findMissingPattern(traindata, covariates, typeofvar,
studyname = "study", treatmentname = "treat", outcomename = "y")
missingPatternTest <- findMissingPattern(testdata, covariates, typeofvar,
studyname = "study", treatmentname = "treat", outcomename = "y")
without_sys_cov <- intersect(missingPatternTest$without_sys_covariates, missingPattern$without_sys_covariates)
if(shrinkage == FALSE){
if(interaction == FALSE){
form <- as.formula(paste0("y ~ ", paste(without_sys_cov, collapse= "+"), " + (1|study) " ))
} else {
form <- as.formula(paste0("y ~ ", "(", paste(without_sys_cov, collapse= "+"), ") * treat + (1|study) + (0 + treat|study)" ))
}
trained_model <- lmer(form, data = traindata)
} else{
if(interaction == FALSE){
form <- as.formula(paste0("y ~ ", paste(without_sys_cov, collapse= "+")))
} else {
form <- as.formula(paste0("y ~ ", "(", paste(without_sys_cov, collapse= "+"), ") * treat" ))
}
lambdas <- 10^seq(3, -3, by = -.1)
data_glmnet <- model.matrix(form, data = traindata)
data_glmnet <- data_glmnet[,-1]
data_glmnet <- cbind(y = traindata$y, data_glmnet = data_glmnet)
cvfit.ridge <- cv.glmnet(as.matrix(data_glmnet[,-1]), as.matrix(data_glmnet[,1]), family = "gaussian", alpha = 0, type.measure = "deviance", lambda = lambdas)
}
if(interaction == FALSE){
form2 <- as.formula(paste0("y ~ ", paste(without_sys_cov, collapse= "+")))
} else {
form2 <- as.formula(paste0("y ~ ", "(", paste(without_sys_cov, collapse= "+"), ") * treat" ))
}
for(studyid in 1:nstudy){
testdata_dummy <- testdata %>% filter(study == studyid)
bb <- model.matrix(form2, data = testdata_dummy)
if(shrinkage == FALSE){
predictions[[studyid]] <- c(bb %*% fixef(trained_model))
} else{
predictions[[studyid]] <- as.vector(bb %*% coef(cvfit.ridge, s = "lambda.min"))
}
}
return(predictions)
}
imputation_prediction <- function(traindata, testdata, method = "imputation", shrinkage = NULL){
if(is.null(shrinkage)){
shrinkage <- FALSE
}
nstudy <- length(unique(testdata$study))
predictions <- list()
#If the dataset contains treatment, it is assumed to have interaction terms as well
interaction <- "treat" %in% colnames(traindata)
covariates <- names(traindata)
covariates <- covariates[grepl("x", covariates)]
if(length(covariates) == 5){
typeofvar <- c("continuous", "binary", "binary", "continuous", "continuous")
names(typeofvar) <- paste0("x", 1:5)
} else if(length(covariates) == 10){
typeofvar <- c("continuous", "binary", "binary", "continuous", "continuous", "continuous", "continuous", "binary", "binary", "binary")
names(typeofvar) <- paste0("x", 1:10)
}
if(method == "imputation"){
imputationapproach <- ipdma.impute(traindata, covariates = covariates, typeofvar = typeofvar, interaction = interaction,
studyname = "study", treatmentname = "treat", outcomename = "y", m = 10)
} else if(method == "imputation_nocluster"){
imputationapproach <- ipdma.impute(traindata, covariates = covariates, typeofvar = typeofvar, sys_impute_method = "pmm", interaction = interaction,
studyname = "study", treatmentname = "treat", outcomename = "y", m = 10)
} else if(method == "imputation_2lglm"){
imputationapproach <- ipdma.impute(traindata, covariates = covariates, typeofvar = typeofvar, sys_impute_method = "2l.glm", interaction = interaction,
studyname = "study", treatmentname = "treat", outcomename = "y", m = 10)
}
imp.list <- imputationapproach$imp.list
for(studyid in 1:nstudy){
testdata_dummy <- testdata %>% filter(study == studyid)
prediction.dummy <- matrix(NA, nrow = dim(testdata_dummy)[1], ncol = length(imp.list))
missingPatternTest <- findMissingPattern(testdata_dummy, covariates, typeofvar,
studyname = "study", treatmentname = "treat", outcomename = "y")
if(shrinkage == FALSE){
if(interaction == FALSE){
form <- as.formula(paste0("y ~ ", paste(missingPatternTest$without_sys_covariates, collapse= "+"), " + (1|study) "))
} else {
form <- as.formula(paste0("y ~ ", "(", paste(missingPatternTest$without_sys_covariates, collapse= "+"), ") * treat + (1|study) + (0 + treat|study)" ))
}
if(interaction == FALSE){
form2 <- as.formula(paste0("y ~ ", paste(missingPatternTest$without_sys_covariates, collapse= "+")))
} else {
form2 <- as.formula(paste0("y ~ ", "(", paste(missingPatternTest$without_sys_covariates, collapse= "+"), ") * treat" ))
}
} else {
if(interaction == FALSE){
form <- form2 <- as.formula(paste0("y ~ ", paste(missingPatternTest$without_sys_covariates, collapse= "+")))
} else {
form <- form2 <- as.formula(paste0("y ~ ", "(", paste(missingPatternTest$without_sys_covariates, collapse= "+"), ") * treat" ))
}
}
for(ii in 1:length(imp.list)){
imp.dummy <- imp.list[[ii]]
if(shrinkage == FALSE){
imp.model <- lmer(form, data = imp.dummy)
} else{
lambdas <- 10^seq(3, -3, by = -.1)
data_glmnet <- model.matrix(form, data = imp.dummy)
data_glmnet <- data_glmnet[,-1]
data_glmnet <- cbind(y = imp.dummy$y, data_glmnet = data_glmnet)
cvfit.ridge <- cv.glmnet(as.matrix(data_glmnet[,-1]), as.matrix(data_glmnet[,1]), family = "gaussian", alpha = 0, type.measure = "deviance", lambda = lambdas)
}
bb <- model.matrix(form2, data = testdata_dummy)
if(shrinkage == FALSE){
prediction.dummy[,ii] <- c(bb %*% fixef(imp.model))
} else{
prediction.dummy[,ii] <- as.vector(bb %*% coef(cvfit.ridge, s = "lambda.min"))
}
}
predictions[[studyid]] <- apply(prediction.dummy, 1, mean)
}
return(predictions)
}
separate_prediction <- function(traindata, testdata){
nstudy <- length(unique(testdata$study))
nstudy2 <- length(unique(traindata$study))
predictions <- list()
#If the dataset contains treatment, it is assumed to have interaction terms as well
interaction <- "treat" %in% colnames(traindata)
covariates <- names(traindata)
covariates <- covariates[grepl("x", covariates)]
if(length(covariates) == 5){
typeofvar <- c("continuous", "binary", "binary", "continuous", "continuous")
names(typeofvar) <- paste0("x", 1:5)
} else if(length(covariates) == 10){
typeofvar <- c("continuous", "binary", "binary", "continuous", "continuous", "continuous", "continuous", "binary", "binary", "binary")
names(typeofvar) <- paste0("x", 1:10)
}
for(studyid in 1:nstudy){
testdata_dummy <- testdata %>% filter(study == studyid)
missingPatternTest <- findMissingPattern(testdata, covariates, typeofvar,
studyname = "study", treatmentname = "treat", outcomename = "y")
prediction_store <- matrix(NA, dim(testdata_dummy)[1], nstudy2)
precision_store <- matrix(NA, dim(testdata_dummy)[1], nstudy2)
for(studyid2 in 1:nstudy2){
traindata_dummy <- traindata %>% filter(study == studyid2)
missingPattern <- findMissingPattern(traindata_dummy, covariates, typeofvar,
studyname = "study", treatmentname = "treat", outcomename = "y")
#use covariates that are not systematically missing in both training and testing dataset
without_sys_cov <- intersect(missingPatternTest$without_sys_covariates, missingPattern$without_sys_covariates)
if(interaction == FALSE){
form <- as.formula(paste0("y ~ ", paste(without_sys_cov, collapse= "+")))
} else {
form <- as.formula(paste0("y ~ ", "(", paste(without_sys_cov, collapse= "+"), ") * treat"))
}
trained_model <- lm(form, data = traindata_dummy)
bb <- model.matrix(form, data = testdata_dummy)
prediction_store[,studyid2] <- bb %*% coef(trained_model)
precision_store[,studyid2] <- 1/(diag(bb %*% vcov(trained_model) %*% t(bb))+ sigma(trained_model)^2)
}
product_store <- prediction_store * precision_store
precision_vec <- apply(precision_store, 1, sum)
final_store <- sweep(product_store, 1, precision_vec, `/`)
predictions[[studyid]] <- apply(final_store, 1, sum)
#prediction[[studyid]] <- apply(prediction_store, 1, mean)
}
return(predictions)
}
wrapper_function <- function(Nstudies = NULL, Ncov = NULL, sys_missing_prob = NULL, magnitude = NULL, heterogeneity = NULL, Nsim = 100, shrinkage = NULL, magnitude.complete = NULL, magnitude.sys = NULL){
testdata <- naivepred <- imputation_noclusterpred <- imputationpred <- separatepred <- list()
if(is.null(shrinkage)){
shrinkage <- FALSE
}
for(i in 1:Nsim){
set.seed(i)
simulated_dataset <- generate_sysmiss_ipdma_example_revised(Nstudies = Nstudies, Ncov = Ncov, sys_missing_prob = sys_missing_prob, magnitude = magnitude,
heterogeneity = heterogeneity, interaction = FALSE, magnitude.complete = magnitude.complete,
magnitude.sys = magnitude.sys)
validation_dataset <- generate_sysmiss_ipdma_example_revised(Nstudies = 10, Ncov = Ncov, sys_missing_prob = 0, magnitude = magnitude,
heterogeneity = heterogeneity, interaction = FALSE, magnitude.complete = magnitude.complete,
magnitude.sys = magnitude.sys)
testdata[[i]] <- findTestingOutcome(validation_dataset)
# naive method
naivepred[[i]] <- NA
if(shrinkage == FALSE){
naivepred[[i]] <- try(naive_prediction(simulated_dataset, validation_dataset))
} else{
naivepred[[i]] <- try(naive_prediction(simulated_dataset, validation_dataset, shrinkage = TRUE))
}
# imputation method - ignoring study level
imputation_noclusterpred[[i]] <- NA
if(shrinkage == FALSE){
imputation_noclusterpred[[i]] <- try(imputation_prediction(simulated_dataset, validation_dataset, method = "imputation_nocluster"))
} else{
imputation_noclusterpred[[i]] <- try(imputation_prediction(simulated_dataset, validation_dataset, method = "imputation_nocluster", shrinkage = TRUE))
}
# imputation method - accounting for study level
imputationpred[[i]] <- NA
if(shrinkage == FALSE){
imputationpred[[i]] <- try(imputation_prediction(simulated_dataset, validation_dataset))
#imputationpred[[i]] <- try(imputation_prediction(simulated_dataset, validation_dataset, method = "imputation_2lglm"))
} else{
imputationpred[[i]] <- try(imputation_prediction(simulated_dataset, validation_dataset, shrinkage = TRUE))
}
# separate method
separatepred[[i]] <- NA
separatepred[[i]] <- try(separate_prediction(simulated_dataset, validation_dataset))
}
list(testdata = testdata, naivepred = naivepred, imputation_noclusterpred = imputation_noclusterpred,
imputationpred = imputationpred, separatepred = separatepred)
}
# From the calculated predictions, finds performance metrics
wrapper_function2 <- function(stored_predictions, aggregation = "ignore"){
Nsim <- length(stored_predictions$testdata)
naive_store <- matrix(NA, nrow = Nsim, ncol = 3)
imputation_noclusterstore <- matrix(NA, nrow = Nsim, ncol = 3)
imputation_store <- matrix(NA, nrow = Nsim, ncol = 3)
separate_store <- matrix(NA, nrow = Nsim, ncol = 3)
for(i in 1:Nsim){
testdata <- stored_predictions$testdata[[i]]
naivepred <- stored_predictions$naivepred[[i]]
imputation_noclusterpred <- stored_predictions$imputation_noclusterpred[[i]]
imputationpred <- stored_predictions$imputationpred[[i]]
separatepred <- stored_predictions$separatepred[[i]]
# naive method
naiveperf <- try(findPerformance(testdata, naivepred, aggregation = aggregation))
naive_store[i,] <- naiveperf
# imputation method - ignoring study level
imputation_noclusterperf <- try(findPerformance(testdata, imputation_noclusterpred, aggregation = aggregation))
imputation_noclusterstore[i,] <- imputation_noclusterperf
# imputation method - accounting for study level
imputationperf <- try(findPerformance(testdata, imputationpred, aggregation = aggregation))
imputation_store[i,] <- imputationperf
# separate method
separateperf <- try(findPerformance(testdata, separatepred, aggregation = aggregation))
separate_store[i,] <- separateperf
}
naive_store_revised <- apply(naive_store, 2, as.numeric)
imputation_noclusterstore_revised <- apply(imputation_noclusterstore, 2, as.numeric)
imputation_store_revised <- apply(imputation_store, 2, as.numeric)
separate_store_revised <- apply(separate_store, 2, as.numeric)
naive_failed <- which(rowSums(is.na(naive_store_revised)) > 0)
imputation_noclusterfailed <- which(rowSums(is.na(imputation_noclusterstore_revised)) > 0)
imputation_failed <- which(rowSums(is.na(imputation_store_revised)) > 0)
separate_failed <- which(rowSums(is.na(separate_store_revised)) > 0)
number_failed_simulations <- c(length(naive_failed), length(imputation_noclusterfailed),
length(imputation_failed), length(separate_failed))
# Set a threshold to exclude from comparison
threshold <- 20
if(length(imputation_failed) <= threshold){
failed_set <- unique(c(naive_failed, imputation_noclusterfailed, imputation_failed, separate_failed))
} else{
failed_set <- unique(c(naive_failed, imputation_noclusterfailed, separate_failed))
}
if(length(failed_set) != 0){
naive_store_revised <- naive_store_revised[-failed_set,]
imputation_noclusterstore_revised <- imputation_noclusterstore_revised[-failed_set,]
imputation_store_revised <- imputation_store_revised[-failed_set,]
separate_store_revised <- separate_store_revised[-failed_set,]
}
# return_matrix is the mean value; return_matrix2 is the Monte Carlo error
return_matrix <- return_matrix2 <- matrix(NA, 4, 3)
return_matrix[1,] <- round(apply(naive_store_revised, 2, mean, na.rm = TRUE), digits = 5)
return_matrix[2,] <- round(apply(imputation_noclusterstore_revised, 2, mean, na.rm = TRUE), digits = 5)
return_matrix2[1,] <- round(apply(naive_store_revised, 2, sd, na.rm = TRUE)/sqrt(length(naive_store_revised)), digits = 5)
return_matrix2[2,] <- round(apply(imputation_noclusterstore_revised, 2, sd, na.rm = TRUE)/ sqrt(length(imputation_noclusterstore_revised)), digits = 5)
if(length(imputation_failed) <= threshold){
return_matrix[3,] <- round(apply(imputation_store_revised, 2, mean, na.rm = TRUE), digits = 5)
return_matrix2[3,] <- round(apply(imputation_store_revised, 2, sd, na.rm = TRUE)/ sqrt(length(imputation_store_revised)), digits = 5)
}
return_matrix[4,] <- round(apply(separate_store_revised, 2, mean, na.rm = TRUE), digits = 5)
return_matrix2[4,] <- round(apply(separate_store_revised, 2, sd, na.rm = TRUE)/ sqrt(length(separate_store_revised)), digits = 5)
#only report MSE and R-squared
return_matrix <- return_matrix[,c(1,3)]
return_matrix2 <- return_matrix2[,c(1,3)]
rownames(return_matrix) <- rownames(return_matrix2) <- c("Naive", "Imputation ignoring heterogeneity", "Imputation accounting heterogeneity", "Separate prediction")
colnames(return_matrix) <- colnames(return_matrix2) <- c("MSE", "R-squared")
return(list(number_failed_simulations = number_failed_simulations, return_matrix = return_matrix, return_matrix2 = return_matrix2))
}
result <- wrapper_function(Nstudies = 2, Ncov = 5, sys_missing_prob = 0.1, magnitude = NULL, heterogeneity = 0.3, shrinkage = TRUE, magnitude.complete = 0.2, magnitude.sys = 0.5)
save(result, file = "simulationR1.RData")
load("simulationR1.RData")
wrapper_function2(result)
load("simulation1.RData")
wrapper_function2(result)
load("simulation1.RData")
wrapper_function2(result)
result
wrapper_function2(result)
remove(list = ls()
)
# We changed name of the methods
# naive method -> restrict predictor method
# separate prediction method -> ensemble method
#devtools::install_github("MikeJSeo/bipd")
library(bipd)
library(dplyr)
library(mvtnorm)
library(lme4)
library(micemd)
setwd("C:/Users/swj88/Documents/Github/phd/missing")
source("helpful.functions.R")
source("simulation.functions.R")
#################################### simulationR1
result <- wrapper_function(Nstudies = 2, Ncov = 5, sys_missing_prob = 0.1, magnitude = NULL, heterogeneity = 0.3, shrinkage = TRUE, magnitude.complete = 0.2, magnitude.sys = 0.5)
save(result, file = "simulationR1.RData")
#################################### simulationR1
result <- wrapper_function(Nstudies = 2, Ncov = 5, sys_missing_prob = 0.1, magnitude = NULL, heterogeneity = 0.3, shrinkage = TRUE, magnitude.complete = 0.2, magnitude.sys = 0.5)
save(result, file = "simulationR1.RData")
load("simulationR1.RData")
wrapper_function2(result)
result <- wrapper_function(Nstudies = 2, Ncov = 5, sys_missing_prob = 0.1, magnitude = NULL, heterogeneity = 0.3, magnitude.complete = 0.2, magnitude.sys = 0.5)
save(result, file = "simulationRR1.RData")
load("simulationR1.RData")
wrapper_function2(result)
load("simulationRR1.RData")
wrapper_function2(result)
load("simulationRR1.RData")
wrapper_function2(result)
load("simulationR1.RData")
wrapper_function2(result)
